1. dir이 주어지고, 한 방향으로 쭉 탐색하기 - 백준 감시

   - 재귀로 진행하지 않아도 된다

   - while문으로 진행 가능

   - ```python
     def go_with_dir(y,x,dir):
     	ny = y
     	nx = x
     	while True:
     		ny += dy[dir]
     		nx += dx[dir]
     		if not (0<=ny<n and 0<=nx<m):
     			break
     		
     		plain[ny][nx] = "방문"
     ```

     

2-1. mod 연산 (나머지)

- 궁극적으로는, 큰 수를 작은 수로 줄이는 것.
- **어떤 숫자의 속성이, 주기성**을 갖고 있다면 사용한다.
- **"숫자 -> 바꿀 숫자" 의 규칙**을 찾으면 된다

[예시]

- 예를 들어, 요일을 구할 때나, 시간을 구할 때 사용한다

  - 오늘이 화요일이라면, 9일 뒤는 무슨 요일일까?
  - 자연스럽게, 7로 나눈 후, 나머지만을 더하게 된다. 왜냐하면, 7일을 주기로 요일이 바뀌기 때문이다. 그래서, 9일 뒤는 목요일이라는 것을 알 수 있다.




[기본]

- **num -> correct num**
- 0 -> 0
- 1 -> 1
- 2 -> 2
- 3 -> 3
- 4 -> 0
- 5 -> 1
- 6 -> 2
- ... 
- **"실제 숫자를 -> 수정 숫자"로 바꾸고 싶은 경우**에 사용한다
- 실제 숫자 % 4를 하면 되는구나가 규칙으로 보임



[코드] - 나중에 코드 작성하면, 다른 코드 추가하기(아래 코드는 너무 억지 느낌)

- ```
  dy = [-1,0,1,0]
  dx = [0,1,0,-1]
  
  dir = 2
  while True:
  	dir += 1
    ny = y + dy[dir%4]
    nx = x + dx[dir%4]
  ```



2-2. 몫

- 규칙성이 **몇 번 반복되는지** 알려줌
- 예를 들어 원소 10개짜리 리스트에서 3개씩 반복된다면, 10 // 3 = 3 이고, 이 몫의 뜻은 해당 규칙성이 3번 반복됨을 말해준다.





3. **미리 케이스 만들어두기** - 백준 틱택토
   - 미리 케이스를 만들어두는 것이다.
   - 틱택토 문제를 풀어보면, 어떤 느낌인지 감이 올 것이다.

[코드]

```python
# 방문할 좌표 케이스 미리 설정해두기
cases = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]]
```



[아이디어를 얻은 블로그]

- https://velog.io/@bbbjihan/BOJ-%EB%B0%B1%EC%A4%80-7682-%ED%8B%B1%ED%83%9D%ED%86%A0-python

   



4. plain 만들 때, **[]를 원소**로 갖는 plain 만들기

- **하나의 좌표에, 객체 2개 이상이 들어가있어야 하는 상황**이 생길 때 사용한다.
- 예를 들어, 체스판 한칸에 체스 말이 2개 이상 들어갈 수 있는 상황이 있다. 이때, 하나의 좌표가 의미하는 것을 리스트([]) 로 만들어서, 값을 하나씩 append하는 식으로 작성한다.

[코드]

```python
plain_with_piece = [list([] for _ in range(n)) for _ in range(n)]
```





5. **for문 1번 + 예외 break**

- **이중 for문을 사용하면, flag가 사용될 확률이 높다**. 두번째 for문이 탐색하는 범위가 4개 정도 이하라면, 해당 조건들 일일히 써보는 것도 나쁘지 않은 선택이다. 이때, case를 만들어두는 것도 방법이 될 수 있다.

- **결론적으로, for문 1번에 예외상황이 등장하면 break 하는 형식으로 코드를 작성하자.**

  - ```python
    stop_x = -1
    # for문
    for j in range(4,10):
      # 예외
      if plain[y][j] == 1 or plain[y+1][j] == 1:
      	break
      # 정상
      stop_x = j
    ```






6. iterable을 순회화면서, 해당  iterable값 바꾸는 방법

   - [백준 20056 - 마법사 상어와 파이어볼]

     - https://jennnn.tistory.com/77 블로그를 보고 알게된 구현방법.

     

   - iterable을 순회한다고 하면, 당연히 for문이 떠오를 것이다.

     - (for v in iterable객체)
     - 문제는 이 경우에는, **순회중인 iterable 객체를 바꿀 수 없다는 것**이다.
     - 예시 : 현재 체스 말이 있다는 표시를 해둔 plain을 생각해보자. 모든 말들의 위치를 특정 로직을 적용시켜 이동시키고 하고 싶다. 그렇다면, 해당 plain의 값들을 하나씩 순회하면서, 현재 탐색중인 말을 plain에서 빼고, 특정 로직을 적용시킨 새로운 좌표 값에 말을 두어야 한다. 즉, plain을 순회하면서도, plain을 수정해야 하는 문제가 생긴 것이다.
     - 이때, 생각할 방법이 while 문을 이용하는 것이다.

     

   - **while문을 이용**해서 iterable 객체를 순회한다면, iterable 객체를 바꿀 수 있다!!

     - 예시 : 현재 체스 말이 있다는 표시를 해둔 plain을 탐색하는 경우를 다시 생각해보자. 현재 위치에서 말을 제거하고, 다른 위치로 이동해야 하므로, 한번의 iteration에서 iterable 객체를 수정해야 하는 경우가 생긴다. 이때, while True와 같은 방법으로 iteration을 순회하도록 작성한다. iteration을 진행하면서, plain에서 값을 하나 빼고, 그 값을 다시 plain에 넣을 수 있는 장점이 있다.
     - 



7. 내가 기본으로 생각하는 plain과 값이 다른 경우

   - 무조건, 내 plain을 기준으로 생각하고 로직을 수행하는 것이 편하다.  dy,dx도 전부 내가 생각하는 방향으로 해뒀기 때문이다.

   - 방법)

     1. **주어진 좌표를, 내가 생각하는 plain의 좌표로 바꾼다**

     2. 로직을 수행한다

     3. **결과 좌표를, 원래 좌표대로 복구시킨다**

   - 예시)

     - ```python
       k,r,n = list(input().split())
       n = int(n)
       k = [8 - (int(k[1])), ord(k[0]) - ord('A')]
       r = [8 - (int(r[1])), ord(r[0]) - ord('A')]
       ```



