자 그럼 커널수준의 문맥에 대해서
설명하도록 하겠습니다
자 커널추진된 문맥에는 특수 레지스터내용
그다음에 의 각종 범용 레지스터내용 자
그 다음에 프로세스에 현재의 각종 자원사용 정보
그 다음에 커널이 프로세스 를 관리하는 데 필요한 관리
정보 이런 것들이 커널수준의 문맥이 되겠습니다

이중에서 특수레지스터에는 또 어떤 것들이 있냐하면
자 프로그램 카운터 이라고 부르죠
프로그램 카운터 다음
수행할 명령에 주소를 담고 있는 레지스터이게
프로그램 카운터가 되겠죠
그 다음에 스텔운영에 필요한 스펙포인트라고 보통 그러죠
그 다음에 상태 레지스터 이라고 그러는데요
프로그램 라고 합니다
여러분들 혹시 모드비트 얼마 전에 설명을 했는데
모두 비트기억이 나죠 모두 비트도 요상태
레지스터의 한 비트에 해당하는 겁니다

자 그러한 것들이 프로그램 수행에 있어서
커널이 관리해야 되는 중요한 문맥에 해당하는 겁니다
그리고 범용 레지스터는 특수레지스터와는 달리
일반 계산용 프로그램 수행용 레지스터가 되겠죠
여기서 먼저 특수레지스터에 대해서
하나하나씩 좀 설명을 하도록 하고요
자 자원 사용 정보나 프로세스관리
정보 등은 주프로세스컨트롤 블록피
이런 걸 설명할 때 설명을 하도록 하겠습니다
먼저 특수레지스터의 어떤 것이 있고
각각의 역할이 무엇인지를 이해하려면
터를 중심으로 하는
동작구조를 조금 이해할 필요가 있습니다
자 이 그림에 대한 이야기인데요
결국 이 그림의 이야기의 시작은
여기 있는 프로그램 카운터 에서
먼저 시작을 해야 할 것 같습니다 는 기본적으로 그렇지 가져온다
이거죠
그 다음에 디코드 그 다음에
익스큐트 이 과정을 계속해서 반복하는 겁니다
자 메인 메모리로부터 명령화
하나씩을 순차적으로 읽고 오게 됩니다
즉 패치를 하게 되는 거죠
자 그래서 이 프로그램 카운터는 다음으로 읽고
올 명령에 주소를 담고 있는 거가 되겠고요
자 이 주소를 얻으레스 버스에 실으면
뭔가 뭔가 하드웨어적인 작용을 통해서
그 다음에 이렇게 해서
명령어가 어디로 해당 명령을 어디로 오냐
하면 명령어로 읽혀들어오게 됩니다
어디서 읽혀들어오냐 하면
메인 메모리에 그 주소에서 읽혀들어오게 되는 거죠 자
그렇게 되면 그 내용을 갖고 뒤 코드를 하게 됩니다
조금 전까지는 패치해온 거고요
이제는 디코드를 하게 되는 거고요
디코드는 이 명령을 해독한 것이니까
그 다음에는 를 시키는 거죠
는 어디에서 왜냐하면
이쪽에 있는 연산 논리 회로 해서 되어지겠죠
자 그게 익스큐입니다
자 그러한 과정에서 여기 있는 이라는 것은 가
이제 다음으로 수행할 명령에 주소
즉 다음으로 패치할 주소를 담고 있는 특수레지스터입니다
만약 방금 전 수행한 명령어가 조건명령이었고
그 결과로 특정 부분으로 점프를 해가야 되는 일이 생겼다면
그 점프해 갈 주소를 여기에 담게 됩니다
물론 그 결과가 점프할 필요가 없는 것이었다면
계속 수행하는 것이 되어야 하니까
그 조건 명령어가 담겼던 주소의 바로
다음 주소가 이 프로그램 카운터 에 담겨 있게 되겠죠
자 그런데 기본적으로 값은 현재
수행한 명령어의 바로 다음
명령어주소로 자동으로 설정되도록 되어있습니다
그러니까 점프가 멀리 일어나지 않는다면
자동적으로 그 다음 명용어가 수행되게 된다
이거 갔겠죠
근데 이게 왜 문맥으로 중요하냐
자 시분할 시스템에서 하필이면
어떤 명령어에서 딱 타임 슬라이스 가 소진이 탁 돼서
스케쥴링 이 일어났는데
우선순위가 떨어져 갖고
다른 프로세스 에게 그 다음 슬라이스를 주게 됐다
그렇게 되면 어떻게 됩니까
현재 돌던 거는 잠시 중지되겠죠 자중지된다는 것
바로 어느 주소까지 수행되고 중지되는 거겠죠
자 그런 후에 나중에 다시 어떤 조건이 만족돼서
속게 되게 된다면 어디서부터 속개되어야 될까요
바로 현재까지 실행되었던 명령어주소그
다음 주소의 명령어부터 실행이 되어야 되겠죠
자 그래서 그 다음 명령에 주소가 어디담겨있냐면
바로 프로그램 카운터 에 담겨 있다는 거죠
그래서 결국에는 이 프로그램 카운터 값을 반드시 보존해야
지만
즉 문맥으로 보존해야지만
시분할 환경에서 한 프로세스가 잠시 중단됐다 가 속개될 때
문제가 없게 된다
그러한 얘기인 거죠
그래서 이 프로그램 카운터 가
매우 중요한 문맥을 형성하는 특수레지스터다
이야기인 것입니다



자 그다음 그렇게 배치
해온 명령어를 디코드해서 실행하게 되면
그 결과로 특정한 상태가 발생할 수 있는데요
그러한 상태를 플래그
레지스터여기 있는 이 플래그
레지스터에 반영을 합니다 이 상태는
다양한 것들이 있는데요
예를 들면 예를 들면은 덧셈이나 곱셈을 했는데
케리가 발생했다든지 이런 것들이 이제 상태에 해당하는 겁니다
아까 얘기했던 프로세스에 상태하고는 좀 다릅니다
요건에 상태를 이야기하는 겁니다
그래서 의 상태 레지스터또는 프로그램 스테이터스
스터 약자로는 이라고 하는 상태
레지스터가 있게 되는 건데요
이것은 방금 전 설명한 대로
현재 명령어실행 후
상태를 기록하는 것이 기본 역할이기도 하지만요
그거 이외에도 디코드 한 명령을 수행할 때
어떤 조건으로도 작용될 수 있고
또는 다음 명령을 수행할 때
중요한 정보로 반영되기도 하는 아주 중요한 레지스터입니다
예를 들어서 요 덧셈을 했는데
올림이 생겼어요 자
그 올림이 생겼다는 정보를 상태
레지스터의 기록을 해 놓는 겁니다
자 그런데 공교롭게도 그 명령을 수행하고 난 다음에
즉 명령을 수행하고 난 다음에 타임
슬라이스 가 딱 끝나갖고 다른 프로세스가 잠시 돌았다
근데 그거돌고 다시 속개될 때 이 올림이 일어났다는
정보를 까 먹었다 어디다 기록하지 않았었다



그러면은 숫자가 날아간 거죠
큰 숫자가 날아간 거죠
연선에 오류가 생기는 거죠
자 그럴 수는 없기 때문에
그런 상태 자체를 잘 보존을 해야 된다
즉 그 S 라는 특수레지스터의 값이
문맥에 중요한 내용이 된다
바로 그것입니다



자 그리고 여기 있는 스텝포인트
약자로는 라고 하는데요
는 프로세스수행 시
콜스틱이 운영된다고 하였는데요 이
콜스텍의 탑에 해당하는 주소를 저장하는데 사용되는 특수 레지스터입니다
이것도 함수 중심의 프로그램을 수행할 때는
굉장히 중요한 내용이 되겠죠
그래서 이것도 특수레지스터로 따로 이렇게 관리를 하고
제공을 하는 것입니다
문맥으로도 따로 관리를 해야 되는 부분입니다
자 이상에서 설명한 SS이
세 개의 특수레지스터는 시분할 시스템에서
프로세스가 번갈아 가면서 수행될 때
중단과 속개를 오류 없이 반복하기 위해서
잘 보존되어야 하는
매우 중요한 스트들이 되는 것입니다





자 여기 있는 다른 레지스트들은 범명 레지스터들입니다
특수레지스트와는 달리 주로 사치현상이나 논리
연산 들을 수행하는 명령어에 사용이 됩니다
특히 그러한 명령에 오퍼로 사용되는 계산목적이
레지스터로서 이 이
법령레지스터의 내용도 프로세스가 중단됐다
속개될 때 잘 보존됐다가
다시 원상복구 되어야만
프로세스가 원활히 돌 수 있겠죠
그래서 커널이 직접 관리하는
커널수준의 문맥이 되겠습니다
자 그렇다면 아까 설명한 사용자 수준의 문맥하고
방금 전에 설명한 같은 특수레지스터들 하고는
어떠한 연관관계가 있을까요
바로 이 그림과 같은데요
자 이미 프로세스가 현재실행되고 있다고 볼 때
콜스텍의 탑주소관리는 레지스터가 하겠죠
그거는 S P 지스타가 스탑을 가리키고 있다
그리고 텍스트 내에 다음 수행할
명령화의 주소는 레지스터에 담겨 있겠죠
저기요 물론 그 명령어가 하나하나 실행되고
난 결과로 생겨나는 의 상태는 에 저장되겠죠
자 이렇게 현 프로세스가 수행될 때는
이러한 특수레지스터들이 그 수행해
주어진 역할들을 함께 하게 됩니다

그런데 스케쥴링 에 의해서
다른 프로세스가 돌아가기
시작하면 이 값들을 모두 덮어쓰고 말겠죠
자 그러면 다시 속개될 때 수행에 문제가 생기겠죠
따라서 다른 프로세스가 수행을 시작하기 전에
반드시 그 시점에 특수레지스터값들을 어딘가에 보존즉
세이브해야 합니다
그곳이 바로 pcb입니다

즉 프로세스콘트롤블록이라는 건데요
자 그곳에 세이브를 했다가 다시 속개될 때
그곳으로부터 restore 해야지, 원활하게 프로그램이 돌아가게 된다



그럼 특수레지스터만 이렇게 pcb를 이용해서
세이브와 리스트를 반복할까요
그렇지는 않습니다 범용 레지스터들도 마찬가지입니다
여기페이지에 다 표현을 안했다 뿐이지
법령레지스트들도 pcb에 의 세이브와 리스트를 반복하게 됩니다

자 그렇다면 pcb가 이러한 레지스터갑들만 보존하는 걸까요 자
그러진 않겠죠
그보다 더 많은 정보들을 담고 있는데요
이에 대해서는 추후 자세히 설명을 하도록 하겠습니다

---

5

pc레지스터와 sp레지스터는 이름
자체가 의미하는 바가 있기 때문에
그 역할들을 금방 이해할 수 있을 것입니다

그러나 즉 psr 추가 설명이 필요할 것 같습니다
참고로 은 라고도 부릅니다
즉 프로그램 라고도 부릅니다
자 얘를 하다 보면 금방 알 수 있을 것 같은데요
펜티엄씨 표의 경우 이
그림과 같은 플래그 레지스터를 갖고 있습니다 이런 형태입니다
자

여기 보면 플래그들 중에 익숙한 내용들이 있습니다

예를 들어서 케리플래그 연산 결과
올림이 일어났는지를 기록하고 있는 건데요
플레이가 죠 가 어디 있습니까 바로 요기에 있죠
케리가 일어나면 요 비트의 일이라고 표시가 된다 이겁니다

또 제로 플래그가 있습니다
여기 제로 플래그 제가 플래거는 ZF로 표시되죠
그 플래그 레지스터에 육번 비트의 표시되게 돼 있는데요
방금 전 논리 연산 결과가 투루 였는지 펄스였는지
그런 것들을 여기다가 담고 있게 됩니다

OF는 어디냐면 여기있습니다
자 계산 결과 비트수를 초과했는지 등이 이제
여기에 그 상태로 기록되게 되는거죠

사실 이러한 내용은 컴퓨터 구조 시간에
이미 배웠을 것으로 알기 때문에
자세한 내용은 생략하도록 하겠습니다

대신 여기 있는 위키피디아의 자료와
링크를 좀 더 참고해서 들여다 보면 좋을 것 같습니다



아무튼 플래그레지스터는 위와
같은 내용을 담고 있다는 것인데요
프로세스에 중단과 속개를 위해서는
반드시 보존되어야 하는 중요한 내용인 것은 분명합니다



예를 들어 AND 명령을 수행하고
난 결과가 투루 였다고 합시다
즉 ZF 비트가 일이 된 거죠
그런데 곧바로 스케쥴링 이 일어나서
다른 프로세스를 수행시키고 난 후에
나중에 속개하게 될 때 이 플래그가 영일지 일일지
보장이 안 되면 큰 문제인 거죠



만약 그 값이 영으로 바뀌어있었다면
속개된 후 프로세스는 엉망이 될 겁니다

따라서 잘 보존했다가 속개시에 꼭 restore를 하고
속개해야 하는 내용인 것입니다
방금 전에 예는 펜티엄의 예였고요

----

6

자 이번 것은 암계열의 CPU에 있는 PSR 사례입니다
여기서는 커런트 프로그램이라고 CPSR부릅니다 자
여기도 보면 이십팔 번에서 삼십 일번 비트의 유사한 플래그들이 다 있습니다
대표적인 네 가지 플래그라고도 NZCV라고 줄여서 부르기도 합니다

자 이러한 플래그뿐만 아니라
인터럽트 enable disable
이런 다양한 플래그들을 여기다 담고 있습니다

참고로 암프로세스에 경우
프로세스수행모두가 여러 가지가 있어서
모드에 따라서 적합하게 작동을 하도록
아주 정교하게 설계가 돼 있는데요

자 이전 에서 언급한 패스트인터럽트 인터럽트
그리고 트랩 이런 것과
관련된 다양한 모드들이 함께 구분되어 동작되도록 되어있습니다

즉 모드가 이러한 여러가지 모드가 있다는 거죠
여러 가지 모두가 있어서 이런 모드로 적
적절하게 변경을 해가면서 수행이 될 수 있도록
이렇게 되어 있습니다

참고로 여기 있는 요 자
nzcv : overflow, carry, zero, negative
약자인 것을 기억해 두면 유용할 것 같습니다
그런 것들이 상태 플래그가 되겠죠 

---

7

자
이제 까지는 프로세스에 문맥에 대해서 설명했습니다
프로세스가 중단되었다가 다시 속개되려면
프로세스에 모든 실행 정부가 중단시에는 보존 되었다가
속개시에는 그대로 원상복구 되어야 하는데요

그러한 프로세스에 모든 실행
정보를 문맥이라고 한다 라고 요약할 수 있겠습니다

그럼 다시 말해서 프로세스에
중단과 속개에 문맥보존이 매우 중요하다는 것인데요

그래서 그러한 작업들을 총체적으로 **문맥교환**이라고 부릅니다 



이 문맥교환에 대해서
좀 더 자세히 설명을 하도록 하겠습니다
자 문맥교환이라는 것은
**바로 cpu를 다른 프로세스 로 넘기는 작업이다**
**이렇게 한마디로 정의가 될 수 있겠는데요**

이것은 cpu라는 자원 입장에서 이야기를 한 것이고요
사실 **cpu가 현재의 프로세스를 중단하고 다른 프로세스를 수행시키는 작업** 

이렇게 표현해도 마찬가지가 되겠습니다

자 그럼 문맥교환작업이 일어나면
실행이 정지되는 프로세스에 문맥은 보존을 시키고
그 대신 새로 실행되어야 되는 프로세스에
문맥을 갖고 와서 활성화 시켜줘야 되겠죠

자 그런데 문맥을 구성하는 내용이
여러가지가 있다고 했었죠

일단 사용자 문맥이 있고 커널문맥이 있다고 했는데요

자 사용자 문맥은 그럼 문맥교환시의 어떻게 될까요

**사용자 문맥**은요
사실 메모리에 그냥 남겨두면 보존이 되는 것입니다 원래 메모리에 있었거든요
자 **사용자 문맥이라는 것은 메모리 현재 상태**를 이야기한다고 얘기했죠
그래서 원래 메모리에 있었기 때문에
그대로 두면 문맥이 보존되는 겁니다

**자 그럼 커널수준의 문맥이 문맥교환에서 굉장히 중요하겠는데요**
자 커널수준 문맥중에서 바로 

프로그램 카운터
스택 포인터
상태 레지스터
범용 레지스터 
즉, cpu내의 레지스터들의 내용들 이것은 반드시 저장되어야 한다.

왜냐하면 다른 프로세스가 될 때 이 값들을 다 뭉개버리거든요
그렇기 때문에 반드시 저장해야 되고
자 나중에 속개될 때 다시 복구되어야 되겠죠

또한 저장되고나면 다른 프로세스가 돌게 될 텐데요
그 다른 프로세스 의 입장에서도 볼 때도
예전에 저장되었던 문맥이 복구가 되어야 되겠죠



그래서 문맥교환이란 

실행 중에 있던 프로세스의 레지스터값들
특수 레지스터와 범용 레지스터값들을 잘 세이브해놓고
어디다 세이브하냐 pcb에다 세이브한다는 거죠

자 그 다음에 스케쥴링 에 의해서 속게 될 프로세스 문맥정보를
그 프로세스의 pcb로부터 restore를 하는 과정
이것이 문맥교환이다 이렇게 이야기할 수 있겠습니다

자 그럼 그 이외에 커널수준 문맥
각종 자원정보와 프로세스관리
정보들은 그럼 어떻게 해야 됩니까

그건 pcb 에 이미 담겨 있기 때문에 그대로 두면 되겠죠
각 프로세스의 pcb에 에 들어 있거든요
그것은 그대로 두면 보존이 되는 것입니다

---

8

자 이렇게 문맥교환에 대해서 알아봤는데요
문맥교환이라는 것은 프로세스에 중단과 속개를 반복할 때
일어나는 문맥의 보존과 복구의 절차다

이렇게 요약을 할 수가 있겠습니다

자 그렇다면 이 문맥교환이 일어나는 시점이라는 관점에서 보면
결국 프로세스가 중단되고
다른 프로세스가 수행되는 경우에
발생한다 라고 볼 수 있겠는데요

자 그렇게 이야기하고 넘어가기에는 너무 막연하죠



자 그래서 문맥교환에 시점에 대해서 좀 더 이야기할 필요가 있겠는데요
이것이 매우 중요한 것이
자 이 문맥교환의 시점이라는 것이 자연스럽게 프로세스에 상태
자 프로세스에 상태라는 주제로 넘어가게 되고
자연히 스케쥴링 과 의
pcb의 설명으로도 이어지게 되어 있습니다

자 우선 개념적으로 볼 때
문맥교환이 일어나는 시점은
크게 네 가지의 시점으로 볼 수 있겠습니다

첫번째가 **시분할 기반의 스케쥴링**
자 스케쥴링 이 일어나는 시점에 문맥교환이 일어날 수 있다
자 스케쥴링 은 언제 일어나냐고요
기본적으로 타임 슬라이스 가 소진되었을 때
스케쥴링 이 일어나겠죠

두 번째로 문맥교환이 일어날 수 있는 그런 시점은
**인터럽트** 로 인해서 가 선점당할 때다 이겁니다
인터럽트 가 들어왔을 때 다 이거죠

셋째로는 프로세스 스스로가 **입출력 요청**을 하게 되면
당연히 다른 프로세스를 cpu가 돌려야 되겠죠
그 경우 문맥교환이 일어날 수 있다

자 네 번째로 프로세스 스스로
다른 프로세스가 보낼
**시그널에 대한 대기요청**을 해서 cpu를 반납할 때

즉 다른 프로세스에 어떤 상태 변화를 기다리기 위해서
대기를 해야 될 경우 마냥 대기할 수는 없으니까 cpu를 반납함으로써

잠시 다른 프로세스가 돌아야 되는데
자 그것을 위해서 문맥교환이 일어난다



이 네 가지를 놓고 볼 때
두 개씩 공통점이 있습니다

자 위에 두개는 문맥교환이 자발적으로 일어나지 않고
**비자발적**으로 나는 겁니다

스 스케쥴링 당하죠 인터럽트 당합니다
그래서 비자발적으로 일어나는 문맥교환이다 

밑에 두 개는 **자발적** 입니다
그에 비해서 입출력을 요청을 하죠
대기를 요청을 하는 겁니다
그 프로세스가 스스로
그래서 이렇게 위에 두개 스케쥴링 과 인터럽트는 비자발적
문맥교환 입출력 요청과 대기요청은 자발적 문맥교환
이렇게 나눠지게 되는데요

자 이렇게 문맥교환의 원인 자발적이냐 비자발적이냐 라는 것하고
그 다음에 프로세스에 상태
그 다음에 그 상태의 천이 이런 것과 엮여서 상당히 중요한 내용들이 이제 설명되겠습니다