### 벨만 포드

- 다익스트라 알고리즘의 optimal한 알고리즘. 다익스트라와 다른 점 딱 한가지는, 특정 엣지가 아닌 모든 엣지에 대해 알고리즘을 진행한다는 점.
- 음수 간선이 존재할 때
- 특정 노드에서 다른 모든 노드로의 최단거리(최소비용)를 구하고 싶을 때.
- 음수 사이클 존재해도 됨
  - 그렇다면 어떻게 음수 사이클 안에서 무한 뺑뺑이 도는 경우를 피할 수 있을까? 방법은 그래프의 정점의 개수를 *V*라고 할 때, **인접 간선을 검사하고 거리 값을 갱신하는 과정을 \*V\*−1번으로 제한**하는 것이다. 그래프에서 시작 정점에서 특정 정점까지 도달하기 위해 거쳐가는 최대 간선 수는 *V*−1개 이기 때문이다. 따라서 경로에 *V*번째 간선이 추가되는 순간 사이클에 진입했다고 판단할 수 있다.


---

#### 필요한 것

1. edges 배열
2. distance 배열

```python
edges = []
dist = [INF] * (n+1)
```



---

#### 코드

- graph가 아니라, edges = [] 를 사용하는 이유

  -  < 그래프를 만들 필요가 없는 이유 > 
     
   - **매번, 모든 간선(엣지)을 확인하기 때문이다.**
     
     - 부연설명을 하자면, 다익스트라는 매번 최단거리 테이블에서 최단거리를 가지는 노드를 선택하고, 해당 노드를 거쳐, 다른 모든 노드로 가는 비용에 대해서만 계산한다. 즉, 해당 노드에 연결된 다른 노드를 파악해야하므로, 그래프를 만들어주어야 한다. 해당 노드에 연결된 다른 노드를 파악한다는 뜻은, 결국, 해당 노드에 연결된 **특정 엣지에 대해서만** 최단거리 비용을 계산하기 때문이다.
     
     - 하지만 벨만포드 알고리즘은, 매번 "모든 간선"을 확인하기 때문에, 굳이 그래프를 만들어 특정 엣지를 고를 필요가 없다. 그냥, **모든 엣지에 대해 알고리즘을 적용**하기 때문에 edges라는 배열에 입력값 다 때려박고, 매 순간마다 배열 내 모든 원소에 대해 알고리즘을 진행하면 된다.
     
   - 즉, 매번 모든 간선을 확인하기 때문에, 그래프를 만들지 않고 edges = [] 라는 배열에 입력받는 것이다.

```python
INF = int(1e9)

def bf(start):
    
    dist[start] = 0
    
    for i in range(n):
        # 매 순간마다 "모든 간선"을 확인한다
         for j in range(m):
            cur = edges[j][0]
            next_node = edges[j][1]
            cost = edges[j][2]
            
            # 현재 간선을 거쳐, 다른 모든 노드로 이동하는 거리가 더 짧은 경우
            if dist[cur] != INF and dist[next_node] > dist[cur] + cost:
                dist[next_node] = dist[cur] + cost
                
                if i == n-1:
                    return True
    
    return False


n,m = map(int,input().split())
edges = []
dist = [INF] * (n+1)

# < 그래프를 만들 필요가 없는 이유 > 
# 매번, 모든 간선을 확인하기 때문이다.

# 부연설명을 하자면, 
# 다익스트라는 매번 최단거리 테이블에서 최단거리를 가지는 노드를 선택하고, 
# 해당 노드를 거쳐, 다른 모든 노드로 가는 비용에 대해서만 계산한다.
# 즉, 해당 노드에 연결된 다른 노드를 파악해야하므로, 그래프를 만들어주어야 한다. 
# 특정 엣지에 대해서만 최단거리 비용을 계산하기 때문이다.

# 하지만 벨만포드 알고리즘은, 매번 "모든 간선"을 확인하기 때문에,
# 굳이 그래프를 만들어 특정 엣지를 고를 필요가 없다.
# 그냥, 모든 엣지에 대해 알고리즘을 적용하기 때문에 edges라는 배열에 입력값 다 때려박고,
# 매 순간마다 배열 내 모든 원소에 대해 알고리즘을 진행하면 된다.

# 즉, 매번 모든 간선을 확인하기 때문에, 그래프를 만들지 않고 edges = [] 라는 배열에 입력받는 것이다.
for _ in range(m):
    a,b,c = map(int,input().split())
    edges.append((a,b,c))
    
negative_cycle = bf(1)

if negative_cycle:
    print("-1")
else:
    for i in range(2,n+1):
        if dist[i] == INF:
            print("-1")
        else:
            print(dist[i])
```

