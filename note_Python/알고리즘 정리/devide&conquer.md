### 분할 정복

- 기본적으로 top-down
- 큰 문제를 "균등하게" 쪼개기 -> 쪼갠 문제 풀기 -> 합치기

---

<내가 분류한 분할정복 유형 2개>

- 쪼갠 문제를 다 풀기만 해서 완료되면 순수 분할 정복
  - 어떤 평면을 계속 n등분해서, 종료지점에서 문제 풀기만 해두면 끝나는 경우. 문제에서 평면이나, 종이 등이 주어짐

- 쪼갠 문제를 풀고, **리턴 값으로 결과를 받아** 모두 다 합쳐서 큰 문제 하나를 풀게 되는 경우는 재귀형 분할 정복
  - 작은 문제를 풀어, 리턴 값을 받아서 활용하는 경우.
  - 아래에 2번 응용을 사용하는 문제에 해당한다.

---

#### 대표 예시) merge sort

- 시복 : n * 2logn = O(nlogn)
- 공간복잡도 : 새로운 배열(n)이 하나 더 필요하므로, 공간복잡도 증가

---

#### 분할 정복 문제 푸는 방법

1. 큰 문제를 작은 문제로 쪼개기

   - **풀 수 있는 가장 작은 문제**로 쪼개야 한다.

   - 풀 수 있다는 뜻은, **문제에서 주어진 문제를 푸는 과정을 적용할 수 있는 문제**를 말하고, 큰 문제를 잘게 쪼개다 보면 그 순간에 도달한다.

     

<여기서부터 재귀 함수 작성> : def recursive() 시작!

1. (작은) 문제를 푸는 로직 작성하기

   - 문제를 푸는 방식을 구현하면 된다. **큰 문제로 생각할 수 있으면 큰 문제로 생각하고, 잘 모르겠으면 작은 문제로 생각해도 된다.** 어차피 같은 함수(로직)로 문제를 풀어나가기 때문!

   - **중요한 것은, 문제를 풀기 위해 필요한 값을, 재귀 함수가 파라미터로 받아야 한다.**

   

2. 큰 문제를 작은 문제로 쪼개는 로직 작성하기

   - 주로 for문을 이용해서 쪼갠다. 균등하게 쪼개는 것을 유의하자.
   - 재귀 함수가 작성되는 곳이다.
   - 작은 문제로 분기하는 곳이다.



```python
def paper(y,x,n):
    
    chk = check(y,x,n)
    
    # 1. (작은) 문제를 푸는 로직 작성
    if chk != -100:
        add_ans(chk)
        return # 작은 문제가 풀린다는 것 = 재귀함수의 종료조건
    
    
    # 2. 큰 문제를 작은 문제로 쪼개는 로직 작성하기(이때, 현재 함수를 재귀 함수로 사용하게 된다.)
    if chk == -100:
        for i in range(3):
            for j in range(3):
                paper(y+(i*n//3), x+(j*n//3), n//3)
```

---

 2번 응용. 큰 문제를 작은 문제로 쪼개는 로직에서, **return값 활용하기**

- 기본적으로 분할정복(재귀)은 top-down 관점으로 보기 때문에, 작은 문제로 분기한다고 말하게 된다.
- 이걸 반대로 생각하면, **작은 문제로 분기하는 곳은, "큰 문제로 합쳐지는 곳" 이기도 하다.**
- **작은 문제를 해결해서 나오는 결과인, 리턴 값을 활용해 큰 문제를 푸는 경우를 의미한다.** 재귀에 가깝다고 볼 수 있다. 잘게 쪼개고, 문제를 해결한 뒤에 그 결과값들을 모아 큰 문제 하나를 해결하는 방식이다.



```python
a,b,c = map(int,input().split())

def multi(b):
    
    if b==1:
        return a %c
    
    tmp = multi(b//2) # 재귀 함수의 리턴 값을 활용함
    
    if b%2 == 0:
        return tmp*tmp %c
    else:
        return tmp*tmp*a % c

print( multi(b) )
```



---

---

분할정복은 위와 같은 로직을 사용한다고 생각하자. 분할정복에 재귀가 기본적으로 들어가기 때문에, 아래와 같은 사항을 확실하게 알아두면 도움이 될 것 같아 한번 정리해보았다. 위의 사항과 조금 별개로 봐두고, 모든 재귀함수에서 이용하는 방식으로 봐주면 헷갈리지 않을 것 같다.

#### 재귀 함수 해석하기(작성하기)

그래서, 재귀 함수 코드를 해석할 때 다음과 같은 사항을 명심하면(언어로 표현할 줄 안다면) 좋다. 구체편과 간단편을 적어둘텐데, 고민을 깊게 해볼 땐 구체편을 읽어보고, **문제를 풀 땐 간단편을 통해 재귀함수를 해석하자(작성하자)**.

<구체편>

1.

- **코드 내부에 재귀함수가 존재하고, 리턴 값이 있다면, **
  **작은 문제(현재 진행 중인 코드 내부의 재귀함수)가 만들어내는 리턴 값이 큰 문제(현재 진행중인 코드)로 합쳐지는 것이다.**(생각해보면, 하나의 코드 흐름이라는 큰 코드에서, 재귀함수를 사용하고 그것의 리턴값을 받아낸다. 그 리턴값을 통해 큰 코드에서 어떤 작업을 진행하기 때문에, 큰 코드에서 작은 코드의 리턴 값은 재귀함수에서 연결고리 역할을 하고, 중요한 역할을 한다는 것을 알 수 있다.)
- 그렇기 때문에, 리턴 값을 활용하는 경우가 많을 뿐더러, 매우 중요하다.

2.

- 작은 문제(현재 진행 중인 코드 내부의 재귀함수)에 대해서, 재귀함수의 해석을 한답시고, 종료조건까지 파고 들어가 모든 동작을 확인할 필요가 없다.
- **재귀함수가 "어떤 동작을 수행하는 함수" 인지 명확하게 파악하고, 재귀함수가 해당 동작을 수행했다고 판단하고 바로 다음 줄로 넘어가 코드를 해석해라.** 마치 print() 함수를 파고들어 끝까지 해석하지 않는 것과 같다. 재귀함수는, 믿고 사용하는 것이다. 그렇게 해야, 내가 작성할 로직이 보인다.

<간단편>

- **재귀함수가 "어떤 동작을 수행하는 함수 + 어떤 결과값을 리턴하는 함수" 인지 명확하게 파악하고, 재귀함수가 해당 동작을 수행했다고 판단하고 바로 다음 줄로 넘어가 코드를 해석해라.**



#### 재귀 함수 해석하기 - 예시

- 예시

  - dfs에서 작은 코드의 리턴 값을 활용해 큰 코드에 합쳐지는 경우. 이건 dfs 코드를 몇개 보면 확실히 감이 잡힐 것이다.

  - 1629_곱셈의 아래 코드

  - ```python
    a,b,c = map(int,input().split())
    
    # 1. "현재 진행중인 코드(큰 코드)"
    def multi(b):
        
        if b==1:
            return a %c
    	# 2. "현재 진행중인 코드 내부의 재귀함수(작은 코드)"
        # 작은 문제인 multi(b//2)의 리턴 값을 받는다. 
    	# 그것이 현재 큰 문제인 mutil(b)의 코드로 존재하고, 해당 값을 이용하여 큰 문제를 풀어내게 된다.
        # 즉, 리턴 값을 통해 큰 문제로 합쳐지게 된다.
        tmp = multi(b//2) 
        
        
        if b%2 == 0:
            return tmp*tmp %c
        else:
            return tmp*tmp*a % c
    
    print( multi(b) )
    ```

    
