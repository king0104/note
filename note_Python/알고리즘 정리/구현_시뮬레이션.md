#### ㄴ시뮬레이션 = "한번의 과정 구현하기 + for문"

- 필연적으로, '한번의 과정'을 여러번 반복하게 될 것이다. 
- 그렇다면, 어떤 **'한번의 과정'을 구현하는 것**이 우리의 목표가 된다.



#### 핵심은, "현재 상태에서 다음 상태를 어떻게 만들 것인가"

- 여러번 반복할 한번의 과정을 구현하는 것이다.
- 여러번 반복해야 하기 때문에, 필연적으로 **현재 상태와 다음 상태**가 생기게 된다. 그렇기 때문에, 우리는 **"현재 상태에서 다음 상태를 어떻게 만들 것인가"** 가 매우 중요한 구현 과정이 된다.



- 반대로 생각하면, **dp적 사고**가 된다, 
- 즉, **"n번째 상태가 되기 위해 n-1번째에서 어떻게 되어야 하지?"** 로 생각할 수 있다.





---

### 시뮬레이션 실수 모음집

#### 전역변수(특히 plain)를 초기화 할 때는, 순서가 매우 중요하다!!

- 전역변수는 어떤 상태값을 가지고 있는 경우가 많다. plain같은 경우, 사과가 있는지 없는지와 같은 상태값이 존재하는 것이 그 예시이다.

- 해당 상태값으로 조건문 분기를 처리하게 되는데, 이때 시뮬레이션에 주어진 순서와 다르게 전역변수를 접근하고 초기화한다면 틀리게 된다. 즉, **시뮬레이션에 주어진 순서를 그대로 따라가는 코딩을 해야한다!!**

  - 예시
    - 먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.
    - 만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.
    - 만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.
  - 사과의 여부를 먼저 체크하고 -> 그 다음 사과를 없애야 하는 것이 중점이다.
  - 그런데, 코드를 간단히 한답시고 두 코드의 공통부분인 "머리를 다음 칸에 위치시키기"를 먼저 진행했는데, 이렇게 되면 plain에 사과를 지워버리고 머리를 다음 칸에 위치시켜버리게 된다. 사과 조건을 처리하지도 않았는데, 사과 존재를 없애버린 것이다!!

  

- 따라서, 전역변수를 초기화할 때는, **순서**를 매우 중요하게 생각하도록 하자

```python
# 사과 여부 확인하고 먹어야함!()
# plain[nhy][nhx] = -1 : 이 코드 때문에 완전 계속 틀림.... 전역변수를 초기화하			는 것은 순서를 매우 중요하게 생각하도록 하자
if plain[nhy][nhx] != 1: # 사과 아니라면
    plain[ty][tx] = 0
    nty = snake_plain[ty][tx][0]
    ntx = snake_plain[ty][tx][1]
    snake_plain[ty][tx][0], snake_plain[ty][tx][1] = 0,0

plain[nhy][nhx] = -1
```

---

### 어떤 상태를 확인하는 코드 구간은?

- 시뮬레이션에서, 정답과 일치하는 상태를 찾아야 하는 경우가 대부분이다. 이때, 그 최종 상태의 값을 확인하는 코드가 존재하는데, 시뮬레이션을 시작하면서 처음부터 상태를 체크하도록 구현하여야 한다. **즉, 상태를 확인하는 코드는 시뮬레이션 이전에 먼저 확인해야 한다.** 왜냐하면, 시뮬레이션을 돌리지 않아도 이미 우리가 원하는 상태가 되어있을 수 있기 때문이다!!!
- 백준 2573 빙산 : 녹는 과정이 일어나기 전부터, 처음부터 두 덩이 이상으로 분리되어 있을 수 있기 때문에 상태 확인 코드를 가장 위에 적어주어야 한다

---

### 어떤 작업을 동시에 처리하기 - list의 얕은 복사 / 깊은 복사

어떤 값을 할당할 때**, 내가 메모리 주소를 넘겨주고 있는건 아닌지 생각해보기!!** 새로운 값을 할당하고 싶다면 deepcopy 사용하자.

- 얕은 복사

  - 주소가 복사되는 것

- 깊은 복사

  - 아예 새로운 객체가 되는 것

  - ```python
    import copy
    next_plain = copy.deepcopy(plain)
    ```

----

### 시뮬레이션 + 백트래킹

- 모든 시뮬레이션을 확인하기 위해 백트래킹이 사용되는 경우가 있다.

- 이때, 현재 plain을 저장해두고, 다음 상태로 넘어갔다가, 백트래킹 해서 다시 현재 plain로 돌아올 때 현재 plain으로 업데이트 해주는 방식이 많이 사용된다.

- ```python
  max_ans = 0
  ans = 0
  def move_fish_and_shark(sy,sx,sdir): #shark y,x,dir
      global ans
      global max_ans
      global plain
  
      # 현재
      ans += plain[sy][sx][0]
      plain[sy][sx][0] = -1
      plain[sy][sx][1] = sdir
      move_fish()
      # _현재 상태 저장하기
      tmp = deepcopy(plain)
  
      # 다음
      ny = sy
      nx = sx
      while True:
          ny += dy[sdir]
          nx += dx[sdir]
          if not (0<=ny<4 and 0<=nx<4):
              break
  
          if 0<=ny<4 and 0<=nx<4 and plain[ny][nx][0] > 0:
              plain[sy][sx][0] = 0
              move_fish_and_shark(ny,nx,plain[ny][nx][1])
              
              # _현재 상태로 복원하기
              plain = deepcopy(tmp)
              ans -= plain[ny][nx][0]
  
      max_ans = max(max_ans,ans)
  ```

  
