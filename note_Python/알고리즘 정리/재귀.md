import sys

sys.setrecursionlimit(10**5)



### 재귀

- 재귀를 사용하려면, **list**가 있어야 한다!!

  - 재귀 자체가 깊게 쭉 들어가는건데, 다 개별적으로 있으면 깊게 쭉 들어갈 수가 없음.
  - dfs의 plain도 이차원 list이다.



- #### 재귀의 단순한 의미

  - x에서 y로 가는데 x 뒤에 재귀가 있으면, 다른 x->y를 하고, 원래 y로 간다

  

- #### 재귀를 그림으로 파헤치는 경우, 이런 식으로 그리자

  - ![image-20220220210816421](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220220210816421.png)
  - top-down을 생각하고, 가장 top 부분을 가장 크게 그리고, 재귀를 통해 들어가는 부분을 작게 그려주자. 이해가 쉽게 될 것이다.



- #### 재귀 코드 작성하기 (2022.4.10)

  - 재귀를 작성할 땐, **1. 현재 상태가 가져야 하는 정보**가 무엇인지 생각하자. 그 정보들이 **파라미터**가 되고, 그 정보들을 조작해서 상태의 값들을 만들어낸다.

  - 같은 말로, **현재 문제를 풀기 위해 가지고 있어야 하는 정보**라고도 할 수 있다.

    - "현재 상태"라는 말에서 주의할 점이 있다. 우리는, **현재 상태의 값으로 다음 상태의 값을 만들어, 다음 재귀함수(ex-dfs함수, 백트래킹 함수)의 파라미터로 넘겨주게 된다.** 즉, **현재 진행 중인 함수에서 다음 상태값이 등장**하게 되는데, 이때, **다음 상태의 값은, "온전한 현재 상태"를 유지하기 위해 "새로운 변수로 할당"**해주어야 한다. 

      start로 어떤 값을 만들어 새로운 값을 만들었다면, 해당 값을 **nstart라는 새로운 변수에 할당**해서 다음 진행될 함수에 파라미터로 넘겨주어야 한다는 것이다. 만약, **현재 상태가 리스트**라면, 다음 상태값은 **새로운 리스트**를 만들어 넘겨주어야 한다. 이때, = 를 사용하면 메모리가 복사되어 깊은 복사가 되므로, **copy()를 사용**하여 얕은 복사를 진행하자.

    - 이것이 중요한 이유는, 재귀함수 특성 상 return이 반드시 일어나기 때문이다. 다음 상태에서 return이 되면, 현재 상태로 돌아오는데, 이때 현재 상태의 변수가 현재 진행 중인 함수의 동작이 완료되었다는 것으로 인해 다음 상태의 값을 가지고 있다면, 우리는 현재 상태의 함수로 돌아오더라도 현재 상태의 값을 온전히 갖고있지 못하게 된다.

    - 특히, 백트래킹이 적용되는 코드에서 중요하게 된다. **백트래킹 시, 다음 상태에서 현재 상태로 돌아오게 된다**. **이때, "온전한 현재 상태"로 돌아와야 한다.** 현재 상태로 돌아올 때 처음에 가지고 있던 "현재 상태가 가져야 하는 정보"가 유지되지 않고 어떤 로직에 의해 (다음 함수에 의할 수도 있고, 현재 함수가 동작되어서 변수값을 바꿨을 수도 있다) 변경되면, 온전한 현재 상태로 돌아온 것이 아님을 명심하자.

    - **우리는 백트래킹으로 현재 상태로 돌아올 때, 온전한 현재 상태로 돌아와야** 또 다른 함수로 진행할 수 있는데, 그렇지 못하면 백트래킹을 할 수 없다는 것을 명심하자.




  - 아래의, "현재 톱니바퀴가 가져야 할 정보" 처럼 말이다.

  - ```python
    # 현재 톱니바퀴가 알아야 할 정보
    # 1. 이전 회전방향
    # 2. 이전 톱니바퀴와의 극 비교
    # 3. 결과 : 회전 방향
    # flag : 현재 기준 이전 톱니바퀴가 오른쪽(-1)/왼쪽(1)에서 왔는지 알려줌
    def check_and_rotate(cur,bf_dir,flag):
    ```
    
    
    
  - 재귀를 작성할 땐, 우리가 만들어내는 재귀함수가 (현재 상태가 가져아하는 정보를 통해)  **2. '어떤 동작을 하는 함수'** 인지 생각해야 한다.

    - 순수 분할정복 같은 경우에는, **종료조건에서(가장 작은 문제에서) 어떤 동작이 일어나도록 재귀함수를 작성한다.** 그래서, **큰 문제를 작은 문제로 쪼개는 부분(재귀함수를 호출하는 부분) & 종료조건에서 문제를 풀어내는 부분(재귀함수가 실제 동작하는 부분)** 으로 코드 작성이 나누어지게 된다.

      'devide&conquer' 편에서 코드 작성편을 보면 이해가 될 것이다.

    - 일반 재귀같은 경우는, 매번 현재 상태마다 동작이 이루어져야 하는 경우가 있다. 이때는, 함수가 어떤 동작을 하도록 할 지, 문제를 보고 스스로 결정해주어야 한다.

    


- 3. **어느 시점에서 더 이상 재귀가 일어나지 않는지** 생각해야 한다. **즉, 종료조건**이 필요하다는 것이다. 해당 시점에, return 코드를 작성한다.

  

#### 재귀 코드로 본, 재귀함수의 의미 (2022.4.10)

- **현재 상태가 가져야 할 정보 + 어떤 동작을 하는 함수 + 종료조건** = 재귀의 의미

  1. 파라미터로 현재 상태가 가져야 할 정보를 받는다. 
  2. 현재 상태의 정보를 통해, 어떤 동작을 진행하게 된다. 즉, 어떤 특정한 로직을 진행하는 것이다. 이 함수가 재귀함수라는 특성 상, 해당 동작은 반복적으로 진행되어야 하는 로직이 된다.
     어떤 동작을 진행하게 되면, 다음 상태에 대한 값을 도출할 수 있다
  3. 다음 상태에 대한 값을, 코드에 존재하는 재귀함수에 파라미터로 넣어준다.

  즉, 재귀함수란, 
  **"1,2,3의 과정을 반복적으로 진행하고 + 현재 상태가 종료조건에 도달했을 때 이전 상태로 돌아가는것" 이다.**




- #### 재귀 코드 해석하기

  - 새로 정의한 함수(재귀함수)가 **'어떤 동작을 하는 함수'** 인지 정확하게 파악하고, 재귀함수로 바로바로 사용하자. 

    - 굳이, n==1 과 같이 동작이 수행되는 가장 마지막 단위**(즉, 재귀의 종료조건)**까지 재귀를 내려서 해석할 필요가 없다는 것이다. 재귀함수를 작성했으면, 믿고 사용해라.

    

- #### 재귀 코드 해석하기 - 예시편

  - 하노이탑 이동 순서에서 만든 재귀함수 move()의 동작은,

    - "n개의 탑을, f에서 t로 이동시키는 함수" 이다. 그렇다면, 재귀함수인 move()가 사용되는 부분은 재귀함수의 종료조건까지 내려가서 해석할 필요가 없다. **move() 가 적힌 코드는, 그냥 "n개의 탑을, f에서 t로 이동시키는 코드 부분" 이라고 생각하고 바로 다음 코드로 넘어가서 해석하면 된다는 뜻이다.**

    - 재귀 함수를 타고 들어가서 종료조건까지 간 후, 다시 올라오는 수고를 하지 않아도 된다는 것이다!



---

#### 11729_하노이탑이동순서

- 재귀함수를 만든다는 것은, 어떤 하나의 동작을 하는 함수를 작성했다는 것이다. print 함수의 의미만 알고 그냥 바로 쓰는 것처럼, 우리가 새로 정의한 재귀함수도 '의미'만 정확하게 알고 바로 사용하면 된다.
- 새로 정의한 함수(재귀함수)가 **'어떤 동작을 하는 함수'** 인지 정확하게 파악하고, 재귀함수로 바로바로 사용하자. 
  - 굳이, n==1 과 같이 동작이 수행되는 가장 마지막 단위**(즉, 재귀의 종료조건)**까지 재귀를 내려서 해석할 필요가 없다는 것이다. 재귀함수를 작성했으면, 믿고 사용해라.


---

<코드 상에서 재귀함수의 의미 - 예시 move() >

- 하노이탑 이동 순서에서 만든 재귀함수 move()의 동작은,

  - "n개의 탑을, f에서 t로 이동시키는 함수" 이다. 그렇다면, 재귀함수인 move()가 사용되는 부분은 재귀함수의 종료조건까지 내려가서 해석할 필요가 없다. **move() 가 적힌 코드는, 그냥 "n개의 탑을, f에서 t로 이동시키는 코드 부분" 이라고 생각하고 바로 다음 코드로 넘어가서 해석하면 된다는 뜻이다.**

  - 재귀 함수를 타고 들어가서 종료조건까지 갈 필요가 없다는 것이다!

---



- 현재 상태가 가져야 하는 정보?
  - 몇개를 이동시키는지
  - 
