### 2주차

개괄적인 내용은 이렇다.

응용프로그램이 어떤 함수를 호출할 때, 커널, 장치, cpu는 어떻게 동작할 것인가? 에 대한 내용을 다루는 것이다.



1. 시스템 호출과 커널

응용프로그램 내에서 시스템 콜 read() 을 진행하면, 시스템 콜 -> cpu -> ISR을 호출 -> 디바이스 드라이버 내의 실제 구현 함수인 sys_read()에 도달한다.



2. 입출력 시스템

2-1. 커널에서 디바이스 드라이버로 넘어가는 방법을 이야기한다.

커널 내 ISR을 호출하고, **실제 구현 함수가 담겨있는 device driver**로 넘어간다.

DD의 특징

- 커널 내에 있다
- **실제 구현 함수**가 담겨져있다
- 커널 내에 존재하므로, 커널 내의 함수 직접 접근 가능하다.
- 커널과 dd의 연결 : **driver - kernel Interface**
  - 디바이스 드라이버가 바뀌면, 커널 전체를 recompile하기 힘드므로, 필요한 드라이버만 plug&play 할 수 있도록 구성해줌



2-2. 디바이스 드라이버에서 디바이스 컨트롤러, 즉 장치 부분으로 넘어가는 방법을 얘기한다.

핵심은. "DC"의 레지스터에 접근하는 것

DD에서, DC의 명령 레지스터에 명령을 적재하고, 자료 레지스터에는 저장공간에 대한 포인터 저장해둠(커널 내 메모리에 대한 포인터임. 자료 받아오기 위함.)

1. 레지스터 접근 방식
   - 격리형 입출력
   - **메모리 사상형** 입출력
2. 자료이동방식
   - 직접 입출력 : CPU가, [메인 메모리 <-> DC내 자료 레지스터 사이]의 자료 이동을 매번 직접 관장
   - **DMA** : 독자적으로 메모리에 접근 가능
     - **cycle stealing** 기법 사용함
3. 제어 방법
   - 폴링 방식 : CPU가 DC의 상태 레지스터를 계속 checking  하는 것
   - 인터럽트 방식 : DC에서 CPU에게 인터럽트 발생시킴
     - **인터럽트 마스크**가 사용된다.





#### 응용프로그램 시스템 호출 -> 커널

( = 응용 프로그램 -> 커널 내 함수)

- 인터럽트 VS 트랩
- 인터럽트
  - 하드웨어에 의하여 ISR 호출
  - 하드웨어 -> CPU -> MEMORY의 커널 내의 ISR 호출
- 트랩
  - 소프트웨어에 의하여 ISR 호출
  - 메모리에 올라와있는 응용프로그램에서 시스템콜 사용 -> CPU -> MEMORY의 커널 내의 ISR 호출



#### 커널 -> device

(정확히는. device driver -> device controller)

