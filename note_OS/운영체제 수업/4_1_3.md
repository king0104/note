1

자 이제까지 프로세스에 상태
그리고 상태천의 에 대하여 설명을 하였습니다

그렇다면 이보다 먼저 공부한 문맥이라는 것이 있었죠
근데 그 문맥이라는 것하고
그 상태 라는 것들은 도대체 어디에 표시 또는 보관되는 것일까요

그 보관되는 실체, 담는 실체는 무엇일까요
그것을 바로 **프로세스 제어 블록**
즉 **프로세스콘트롤블록** pcb이라고 하는 것입니다

프로세스의 일생동안
해당 프로세스에 모든 정적이고 동적인 정보를 저장하는 저장소입니다
결국 프로세스에 문맥을 저장하는 자료 구조이자
현재 프로세스에 상태
그리고 메모리이나 파일 통신 등 각종 자원정보가 저장되는 저장소인 셈입니다

따라서 pcb는 프로세스를 관리하기 위한 실체라고 볼 수가 있습니다

참고로 리눅스 의 경우
에 해당하는 커널레자료 구조 이름은 task struct입니다
좀 더 공부를 원한다면
 task struct 대한 자료를 찾아보면
도움이 되리라고 생각됩니다

아울러 개념적으로 볼 때
이제까지 설명한 프로세스상태천이도
**그 상태천이도에 있었던 준비리스트 나 대기 리스트**
**그것이 결국에는 pcb의 리스트**였던 셈인거죠

단 pcb라는 자료 구조 자체가 리스트들로
이리저리 옮겨 다니도록 구현하지는 않겠죠
분명 pcb의 포인터가 리스트를 옮겨 다닐 것입니다

자 포인터를 잘 다루는 라는 c언어가 왜 시스템
프로그래밍 언어로 적합한지는
바로 이런 것에 있는 겁니다



자 아무튼 상태천이도에  있었던 
**준비리스트나 대기리스트는 결국에 pcb 포인터의 리스트들이다**
바로 이 말입니다



자 여기서 한 가지 짚고 넘어갈 것이 있는데요
다섯 가지 상태 중에 실행상태라는 것이 있었습니다

자 그 실행 상태에 정체는 조금 다릅니다
자 실행 상태라는 것은 그런 준비리스트나 대기 리스트 같은 리스트를 담고 있는 것이 아니라

그거는 프로세스가 실행된다는 사실인 것입니다
그냥 즉 상태표지만 있는 거죠

그리고 실질적으로 cpu가 그 프로세스를 돌리는 것이고요
그래서 pcb에 실행 상태
즉 러닝이라고 상태를 표시하는 겁니다

자 단 pcb는 어디에 존재하냐면
그냥 준비리스트에 존재합니다
그래서 pcb의 상태표시란에 러닝상태로 표시하고
pcb는 준비리스트에 그냥 존재 하면서 cpu가 그 프로세스를 타임 슬라이스 동안 실행시키는 거죠

자 그러한 특수한 상태에 있는 것이 실행 상태다
이렇게 알고 계시면 되겠습니다

---

2 

#### pcb의 내용

자 결국 **프로세스 하나마다 커널 내의 자료 구조인 pcb가 만들어져서**
**사실은 커널은 pcb를 관리하는 것이다**
바로 그런 내용인데요

자 그럼 pcb를 구성하는 내용에는 어떤 것이 있을까요
사실 이제까지 하나하나
공부했던 내용들이 거의 망라되어 저장되게 됩니다

여기 프로세스상태가 있죠
자 아마 다섯 가지 상태를 나타낸
define 된 값들 중 하나가 기록되고 있을 겁니다

이런 상태들의 define값들이 필드 에 들어가겠죠

커널문맥에 해당하는 레지스터 문맥정보
자원 할당 및 사용정보
커널이 pcb를 관리하는 데 필요한 관리 정보
그것에 해당하는 연결 리스트 정보 이런 것들이 여기 들어있습니다

이외에도 당연히 프로세스고유 식별번호 즉 프로세스 아이디 죠
그 다음에 사용자 정보 
스케쥴링 정보 
메모리 현재 사용 정보
이런 것들이 다 여기 망라되어 에 들어가서
**프로세스마다 그 자료 구조가 생성 돼서 그것을 커널이 관리하는 거다** 바로 이것입니다



자 여기서 **cpu 스케쥴링 정보**는 조금 눈에 띕니다
사실 스케쥴링 은 스케쥴링 알고리즘에 의해서 실행되는데요

보통 스케쥴링 알고리즘은 각종 정보를 분석해서
**최고의 우선순위 프로세스를 결정**해 주어야 하기 때문에
이를 위해서는 어딘가에
이에 필요한 정보들이 저장되어 있어야겠죠

그 어딘가가 바로 **pcb**가 되겠는데요
여기 보면 현재 우선순위
그 다음에 아울러 최근 사용량 대기했던 시간
잔여 타임 슬라이스 등 다음 챕터에서
배우게 될 그런 **cpu 우선순위결정에 필요한 정보들**
**이런 것들이 여기다 포함된다**고 보시면 되겠습니다

자 여기 사실은 이것이 바로 프로세스 컨트롤
블락인데 

이 pcb이라는 것이 커널이
프로세스 를 관리하는 실체이다
바로 이 말입니다

---

3

#### 문맥교환과 pcb

지난번에 문맥교환을 또 설명한 바 있는데요 이
문맥교환이라는 것과 pcb의 역할이
아주 밀접한 관계가 있습니다
그 두 개를 연결지어서 잠깐 생각을 해보도록 하겠습니다

여기 두 개의 프로세스가 있습니다 p0와 p1입니다 자
2 프로세스밖에 없음으로
서로의 입출력 시간을 틈타서
번갈아 가면서 실행이 될 겁니다

자 그림을 보면 p0 실행되다가
예를 들어 입출력 시스템 콜를 호출하게 되면
p0의 pcb인 pcb0에 문맥을 저장하게 되고

p1의 문맥을 pcb1으로부터 reload를 또는 restore를 해서 cpu로 load를 하겠죠
그러면 p1이 속개되게 되겠죠

그렇게 그러던 중
p1에서 다시 입출력시스템 콜을 호출하면
p1의 문맥을 저장한 후에 pcb0에 저장된 문맥을 리로드해서 또는 리스토어를 해서 

p0를 다시 실행시키게 되겠죠



자 이렇게 **pcb를 문맥교환을 위한 저장소**로 활용해서 번갈아 가며
실행을 하는 것이 되겠습니다

**따라서 문맥교환에는 pcb가 반드시 이용되게 된다**
**바로 이것입니다**