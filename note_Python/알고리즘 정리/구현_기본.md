### for문 사용법 (= for문 + 업데이트) (-1)

- **for문 바로 위에 초기값 한번만 설정하기**

- **for문에서 (특정 조건 만족 시) 업데이트 하기**

  - ```python
    ans = 0 # 1. for문 바로 위에 초기값 한번만 설정하기
    
    for i in range(5)
    
    	if i > ans: # 2. for문에서 (특정 조건 만족 시) 업데이트하기
    		ans = i
    	
    print(ans)
    ```




### 조건문 사용하기

- 조건문에서의 "비교" : **같은 것**을 비교하는 것. 더해지거나 곱해진다고 헷갈리지 말자

  - 예를 들어, 거리라던지, 위치라던지 하는 것. 

  - ```python
    # 아래의 코드는, "거리" 라는 같은 값을 비교하는 중이다.
    if home >= cur + mid:
    ```

    

- 조건으로 return 할 줄 알기

  - ```python
    return cnt >= c
    # if cnt >= c:
    #     return True
    # else:
    #     return False
    ```





### 변수 사용하기

- **새로운 변수가 기존 변수와 겹치지 않도록 주의**!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! - 특히, 기존 코드를 고쳐보거나 수정해볼때, 이전 변수명들이 기억 안나서 겹치는 변수를 만들 수 있으니, 항상 주의하자. 이걸로 두시간은 잡아먹음...



- **중복되는 코드(변수) 하나로 합치기**

  - 아래 코드는, x에 대한 코드가 2번 사용된다. 그 두개를 합쳐서 중간 x에 그냥 넣어버리면, 굳이 x를 사용하기 위해 여러번 초기화하지 않아도 된다.

  - ```python
    # 더러운 코드
    cur = home_list[0]
    x = cur + mid
        
    cnt = 1
    for home in home_list:
        if home >= x:
            cur = home # 다음 위치로 갱신
            cnt += 1 # 공유기 1대 설치
            x = cur + mid
    ```

  - ```python
    # 깔끔한 코드(x 하나로 합침)
    cur = -1e9
    cnt = 0
    	for home in home_list:
    		if home >= cur + mid:
    			cur = home # 다음 위치로 갱신
    			cnt += 1 # 공유기 1대 설치
    ```




### 함수 작성하기

- **로직이 함수를 건너뛰는 경우.**.. 가 크지 않게 하기

  - 함수 내부에서 다 처리되지 않고, 다른 함수로 로직들이 건너뛰어서 넘어가면, 사실 제대로 함수를 작성한 것이 아니다. 함수는 함수 그 자체만으로 역할을 다 할 수 있으면 좋다.

  - **예외처리를 많이 해두어야 하는 경우, flag로 함수 자체를 부분부분으로 분리하는 경우라면, 함수 자체를 분리하는 경우를 생각해보자.**

    - 예외처리가 아니라, 함수 2개로 예외 처리 경우, 예외 처리하지 않는 경우 이런식으로 나누라는 것이다.

    

- **규칙있게 겹치는 로직 -> 합치기!!!**

  - ```python
    # 규칙 있게 겹치는 로직
    elif flag == 1:
        check_and_rotate(cur+1,dir,1)
            
    elif flag == -1:
        check_and_rotate(cur-1,dir,-1)
        
    # 합친 로직
    check_and_rotate(cur+flag,dir,flag)
    ```






### from 모듈 import * 

1. import os
   - os 모듈을 불러오는 것

2. from os import *
   - os모듈로부터 모두(\*) import



**import만 사용**하면 모듈 안의 함수를 사용할 때, **모듈명.함수명( )**으로 하고, **from을 사용**하면 바로 **함수명( )**으로 사용



### range 사용법

- 기본적으로, **range(start,end,step)** 임을 명심해야 한다

  - **start, end 라는 것이 중요한데, 시작지점과 끝지점이라는 것을 명심해야 한다!!!!!!!!!**

  - 실제로 내가 틀렸는데 눈치채지 못한 코드는, 시작 지점이 sy이고 끝 지점은 n개 뒤의 값일 경우인데,
    - 틀린 답 : range(sy,n)
    - 정답 : range(sy,sy+n)
    - 틀린 답으로 적어서 틀렸다.
  - 참고) 틀린 문제 : 백준 1780_종이의개수
    - ![image-20220723111132154](/Users/yoon/Library/Application Support/typora-user-images/image-20220723111132154.png)
    - 이 부분 틀림.....ㅠㅜ





### 길이(크기)가 같은 배열을 동시 접근할 때

#### 방법 1 : 인덱스로 접근하기

1. 하나의 배열의 길이로 인덱스를 만든다
2. haps[i], v_coors[i] 처럼, 인덱스로 각각을 접근한다

```python
def move_population(haps,v_coords):
    for i in range(len(haps)):
        for y,x in v_coords[i]:
            plain[y][x] = haps[i]//len(v_coords[i])
```



#### 방법 2 : zip으로 묶어서 하나씩 꺼내기

1. 두 개의 배열을 zip 함수로 묶는다
2. for a,b in zip()을 통해, 각 배열에서 하나씩 값을 뽑아 사용한다.

```python
# 2개의 배열을 zip 함수로 묶는다
def move_population2(haps,v_coords):
    for h,v_coord in zip(haps,v_coords):
        for y,x in v_coord:
            plain[y][x] = h//len(v_coord) 
```



- **두 방법의 시간복잡도 차이는 없으니, 그냥 쓰면 됨.**



### 인덱스 순환시키기

0,1,2,3,4,5,6 이라는 인덱스를 순환하고 싶을 때 다음과 같이 작성하기

- 7->0
- 8->1
- 9->2 이렇게 생각해보면, 몇으로 나눠야하는지 느낌이 온다.

```python
idx = idx+1 if idx<7 else idx%7
```

​    



