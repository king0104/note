### 분할 정복

- 기본적으로 top-down
- 큰 문제를 "균등하게" 쪼개기 -> 쪼갠 문제 풀기 -> 합치기



#### 대표 예시) merge sort

- 시복 : n * 2logn = O(nlogn)
- 공간복잡도 : 새로운 배열(n)이 하나 더 필요하므로, 공간복잡도 증가

---

#### 문풀 과정)

1. 큰 문제를 작은 문제로 쪼개기

   - **풀 수 있는 가장 작은 문제**로 쪼개야 한다.

   - 풀 수 있다는 뜻은, **문제에서 주어진 문제를 푸는 과정을 적용할 수 있는 문제**를 말하고, 큰 문제를 잘게 쪼개다 보면 그 순간에 도달한다.

     

<여기서부터 재귀 함수 작성> : def recursive() 시작!

1. (작은) 문제를 푸는 로직 작성하기

   - 문제를 푸는 방식을 구현하면 된다. **큰 문제로 생각할 수 있으면 큰 문제로 생각하고, 잘 모르겠으면 작은 문제로 생각해도 된다.** 어차피 같은 함수(로직)로 문제를 풀어나가기 때문!

   - **중요한 것은, 문제를 풀기 위해 필요한 값을, 재귀 함수가 파라미터로 받아야 한다.**

   

2. 큰 문제를 작은 문제로 쪼개는 로직 작성하기

   - 주로 for문을 이용해서 쪼갠다. 균등하게 쪼개는 것을 유의하자.
   - 재귀 함수가 작성되는 곳이다.
   - 작은 문제로 분기하는 곳이다.



```python
def paper(y,x,n):
    
    chk = check(y,x,n)
    
    # 1. (작은) 문제를 푸는 로직 작성
    if chk != -100:
        add_ans(chk)
        return # 작은 문제가 풀린다는 것 = 재귀함수의 종료조건
    
    
    # 2. 큰 문제를 작은 문제로 쪼개는 로직 작성하기(이때, 현재 함수를 재귀 함수로 사용하게 된다.)
    if chk == -100:
        for i in range(3):
            for j in range(3):
                paper(y+(i*n//3), x+(j*n//3), n//3)
```

