### 구현

### 역순 range 잘 사용하자!!!!! 

- range(0,n)을 역순으로 사용하고 싶다면??  -> (n-1,-1,-1)이다!!!!!!!!!!!!!!!!!!!!! end값 -1으로 반드시!!!!!!!!

  - ```python
    range(n-1,-1,-1)
    ```



### 변하는 부분에 집중 & 코드 줄이기

- 시뮬레이션에서, 어떤 과정이 진행되면서 값이 변경되는 부분이 존재하기 마련이다. 값이 변경되는 부분이 문제가 원하는 부분인 경우가 많기 때문에, 그 부분을 잘 활용하자. 조금 추상적이지만, 이런 개념을 알고있으면 도움이 될 것 같아 적는다. 이런 상황을 조금 더 구체화 시키면 다음과 같다.

- 예를 들어, 20055_컨베이어벨트 문제에서 4번 과정이, 컨베이어 벨트 전체에서 내구도가 0인 갯수를 찾아 일정 갯수 이상이 되면 종료하는 부분을 말할 수 있다.

- ```python
  step = 1
  zd_cnt = 0 # 내구도가 0인 갯수
  while True:
      # 1. 벨트 회전
      # 내구도 유지, 내리는 위치라면 내리기
      tq.appendleft(tq.pop())
      rq.appendleft(rq.pop())
      if rq[n-1] == 1:
          rq[n-1] = 0
      
      # 2. 로봇 옮기기
      for idx in range(n-1,-1,-1):
          if rq[idx] == 1 and idx != n-1 and rq[idx+1] == 0 and tq[idx+1].d >= 1:
              # 1. 로봇 이동
              rq[idx] = 0
              rq[idx+1] = 1
              # 2. 내구도 감소
              tq[idx+1].d -= 1
              if tq[idx+1].d == 0:
                  zd_cnt += 1
              # 3. (옮긴 로봇이)내리는 위치인지 확인
              if idx+1 == n-1:
                  rq[idx+1] = 0
              
                  
      # 3. 내구도 체크 && 로봇 체크 후, 올리기
      if tq[0].d != 0 and rq[0] == 0:
          rq[0] = 1
          tq[0].d -= 1
          if tq[0].d == 0:
              zd_cnt += 1
              
      # 4. 내구도 0인 칸 개수 확인 후, 종료  
      if zd_cnt >= k:
          print(step)
          exit()
              
      step += 1
  ```

  

  1. 한번 어떤 과정을 할 때 마다, for문으로 전체 queue를 탐색해서 O(n)으로 (결국엔 n^2이 될거다. 반복문 안의 반복문이니까) 내구도 0인 개수를 찾는 방식이 있다. 아주 그냥 쌩 노다가인 것이다.
  2. 변하는 부분에 집중해서 생각해보자. 그러면, 내구도가 0인 것이 만들어지는 순간에만 체크하면 된다. 즉, 내구도가 줄어들 때에만, 그 칸의 내구도가 0이 되었나를 체크하고, count를 하나 늘려주면 된다. 위의 코드에서, #2, #3 마지막 부분에 존재한다. #4에서 전체 내구도 0인 갯수 체크한다.

  - 위와 같이, 전체 탐색이 아닌 변하는 부분에서만 개별 탐색을 통해서 시간복잡도를 줄일 수 있게 된다. (n -> 1로 줄임)

- 정리하면,

  1. **어떤 값이 변하는 부분에 집중하자.**
  2. **코드를 줄일 수 있다면, 줄이자(이 부분은 항상 명심하면 좋다. 반복문을 줄일 수 있으면 줄이고, 한두번만 사용되는 쓸데없는 변수는 줄이는 것이, 코드를 읽을 때 훨씬 편하다**.



### deque와 list

#### del 진행시, list 사용

- deque는 원하는 위치의 delete가 오류나는 경우가 생긴다. 또한 pop(idx)로 원하는 위치의 del을 하는 것이 아니다. **따라서, 원하는 위치의 값을 delete하는 경우에는, list 사용하자.**



### 시간순

1. 객체를 만들어 고유 시간을 저장해두는 방법
2. queue(혹은 stack)
   - **먼저 넣은 것은 먼저 나오는 속성이 있다.** 시간 순서가 자연스럽게 반영되기 때문에, 시간 순으로 정렬(또는 어떤 작업)을 해야한다고 하면 **queue를 생각하자. index가 작은 것이( [0], [1] .. ) 시간 순으로 앞서는 것이다!!**



### 해시배열

- 해시 배열 = **"확인용 배열"**
- **인덱스**가 몇번 나오는지 저장해두는 배열 (인덱스에 해당하는 값이 몇번 나오는지 저장하는 배열)
- 인덱스가 아주 중요한 키워드이다. 인덱스를 잃어버리는 순간, 해시 배열의 의미가 사라진다. 따라서, 해시 배열에서 값을 뽑기만 하는 것이 아니라 추가적인 작업을 한다면, **값과 인덱스를 동시에 가지고 있어야 한다!!!!**
- 해시 배열 자체가 인덱스와 값을 동시에 가지고 있다. 따라서, 해시배열을 활용할 때에도 인덱스와 값을 동시에 가지고 있어야 한다. 즉, 어떤 값에 해당하는 **인덱스를 반드시 가지고 있어야 한다!!**



