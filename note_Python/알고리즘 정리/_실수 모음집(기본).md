- 2022/3/5
  - **진짜 = 랑 == 랑 구별 잘 해서 쓰자.** = 를 == 로 썼는데 그것도 모르고 계속 디버깅.... 에러도 안뜨니까 대입연산자랑 비교연산자 잘 구별하기!



- 2022/3/16 - 별찍기 11에서 있었던 오류

  - 24번째에서 시작하길래, 파라미터로 24를 주었다. 완전 틀린 것!!
  - 배열은 0부터 시작하니까 24번째에서 별이 시작되면, 24-1인 23이 인덱스가 된다!!! 그래서 파라미터로 23을 주어야 한다. **배열의 인덱스는,  ~번째 - 1 or 길이 -1 임을 명심하자!!!!!!!**

  

  - 함수의 파라미터에 일반적인 값이 아니라, 예제에 나온 값을 기준으로 특정 값(23) 을 주었다. 이렇게 해서 틀릴 수도 있으므로, 주의할 것

  

  - 큐를 사용한 작업을 할 때, **기본적으로 종료조건은 큐의 원소가 없을 경우이다. 내가 임의로 주는 것이아니다. 왜냐하면, 큐에 들어간 노드는 방문할 노드이므로, 큐에서 다 빼야지 방문할 노드를 다 방문하게 되는 것이고, 그렇게 작업이 끝나는 것이기 때문이다.**
    - 그래서, **큐에서는 종료조건을 적어주는 대신( if 어쩌구, return), continue 조건을 적어준다. (if 어쩌구, continue).** 왜냐하면, "큐에 넣는 것  = 방문 가능한 노드" 이기 떄문에 방문 가능한 경우에만 큐에 넣어야 하는데, 방문하지 못하는 경우에 도달하면 방문을 막아야 하기 때문에 continue를 통해 큐에 넣는 작업을 중지시키는 것이다.



- 2022/10/4 - PPAP에서 **in [ , , ]** 사용 시 오류

  - stack이, list('PPAP') 또는 list('P') 와 같으면... 이라는 로직을 작성하고 싶어서, == 대신 in을 사용했다.

  - ```py
    # 틀린코드
    if stack in [list('PPAP') or list('P')]
    
    # 정답코드
    if stack in [list('PPAP'),list('P')]
    ```

  - **in [ ] 을 사용하는 경우**, **[ ]안에 여러 상태**를 적는다. 

  - 이때, **[] 안의 구분자는 반드시 ','** 이어야 한다**(or아니다!!)**

  

- 2022/10/11 - 테트로미노에서 2차원 리스트를 3차원으로 만들고 싶을 때, list() 사용
  - **list()는, 리스트가 아닌 것을 리스트로 만들어주는 함수**이다
  - 리스트를 리스트로 또 감싸고 싶을 땐(예를 들어 1차원 리스트를 2차원 리스트로 만들고 싶을 땐) **전체에 [ ] 를 붙여야 한다**



- 2022/10/13 - 낚시왕

[파라미터 변수]

- **함수에서 파라미터로 받은 변수의 값은, 변하지 않는 값**이다.
- 그래서, **파라미터로 받은 변수 값을 바꾸거나 업데이트 하고 싶으면, 함수 내에서 새로운 변수를 선언하고 파라미터 값으로 초기화 한 후, 업데이트를 진행**해야한다.

[deque 사용법]

- **deque는 인덱스로 접근할 수 없다**. 인덱스로 접근하고 싶다면, list() 함수 이용해서 list로 바꾸어주어야 한다.





- 2022/10/14 - 새로운게임2

[변수명 겹치는 상황]

- 코드가 길어지는 경우, **내가 이미 사용한 변수명을 다시 사용하는 경우가 있는데, 매우 주의**하자.

  - 이런 경우에 내가 생각하는 방향과 전혀 다르게 코드가 흘러가는데, 이때 변수명이 겹치지는 않는지 반드시 확인하자!!

  - 특히, 변수를 선언하고, **for문에서 습관적으로 사용하는 변수명과 겹치는 경우**가 있음. 주의...

  - 예시

  - ```python
    i = 0 # 체스 말 번호
    turn = 1
    while True:
      # 0,1,2,3
      print("-------------")
      print("now_picec_num : ", i)
    
      for i in range(n): # 무심코 i를 사용했는데, 내가 체스 말 번호로 지정한 i와 변수명이 겹친다!!!!!!!!
        if end:
        	break
        for j in range(n):
          if len(plain_with_piece[i][j])>= 4:
            print((turn-1)//k + 1)
            end = True
            break
    ```

    

- 2022/10/18 - 나무 재테크

[for A in B 내부에서 B '건드리지' 않기]

- **for문을 도는 대상인 iterator를 '변형하는 것(건드리는 것)'은 절대 안된다!!!!** (예상치 못한 오류가 발생함)

  - 접근은 가능하지만... iterator자체를 변형(건드리기)하는 것은 내가 원하는 결과가 나오질 않는다

  - 예시

  - ```python
    L = [1, 2, 3, 4, 5]
    
    for num in L :
        if num >= 3 : L.pop()
    
    print(L)
            
    # Output
    # 3부터 pop이 될 것 같지만, 3이 pop이 되질 않는다!!!!!!!!
    [1, 2, 3]
    ```

    

  - ```python
    # 나무 재테크 실제 코드
    for idx,v in enumerate(plain_tree[i][j]):
    	if plain_nutrient[i][j] >= v:
    		plain_nutrient[i][j] -= v # 양분 줄이기
    		plain_tree[i][j][idx] += 1 # 나이 증가
    	else:
    		age = plain_tree[i][j].pop() # 이 부분이 잘못됨
    		dead_trees.append([i,j,age//2])
    ```

    