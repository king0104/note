1. 틀린 이유

   - 시간복잡도가 큰 슬라이싱(원소 갯수만큼의 시간복잡도)을 사용해서 코딩함

     - a[1:n] -> o(n-1)

     

2. 본 솔루션 링크

   - 내가 푼 솔루션 봤음

   

3. 솔루션을 떠올리기 위한 근거

   - **슬라이싱을 자주 해야 한다면, 슬라이싱 대신 다른 방법이 있는지** 생각해보기
   - 여기서는, 최대 길이가 10^5 인데, 명령어가 10^5 *5 개여서, 매번 슬라이싱을 하게 되면 10^10 * 5의 시간복잡도가 생긴다. 따라서, 다른 방법을 고안해야 한다.

   

   - 커서를 중심으로 두개의 deque()로 나누어, append(), pop() 을 사용한다
   - deque()는 linked list이므로, 추가, 삭제는 o(1)로 해결 가능하다는 장점이 있다.

   

   - 문자열 합치기 = '<구분자>'.join(iterable<str>)

