### flush(), commit()

![image-20211205172441814](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20211205172441814.png)

- flush() : 지금까지 쓰기지연 저장소에 모아둔 sql문을, 트랜잭션에 다 전달하는 것.
  - DB는 트랜잭션을 가지고 있는 상태
- commit() : 트랜잭션의 sql문을 실제로 db에서 실행하는 것. 
  - DB는 트랜잭션의 SQL문을 실행한 상태. 영구적으로 DB에 저장되었음을 말한다.

---

### 트랜잭션

commit되지 않으면, 롤백!

---

### DDL (.sql)

- 인텔리제이로 해당 코드를 받아온 후, 개발자가 조작하여야 한다.
- varchar(255) 의 수를 줄인다던지, auto_increment를 붙인다던지 해주어야 함

---

### 지연로딩

- 사용 방법
  - fetch = fetchType = LAZY
- 정의
  - 객체 a와 객체 b 간 연관관계가 존재한다고 가정하자. 이 경우 객체 a 의 필드에 다른 객체 b가 들어온다고 가정하자.
  - a.getB.getPrice 를 진행하기 위해, 객체 2개를 전부 다 로딩해야한다는 단점이 있다.
  - 이것을 해소하기 위해, 필요할 때만 로딩하는 것이 지연로딩이다.

---

### proxy

- 정의

  - 깡통 클래스

  - 실제 객체의 앞단에서, 어떤 요청을 대신 받아주는 객체를 말한다.
  - 실제 객체의 자식 관계이어야 한다. 프록시 객체는, "extend [실제 객체]" 로 사용되어져야한다.

- 사용 이유
  - 어떤 작업을 하기 전, 선행작업을 미리 해두기 위해서 프록시 객체를 사용할 수 있다.
- 사용 예시
  - JPA는 하나의 엔티티 객체에 대해, 프록시 객체를 만듬으로써, 다양한 작업을 수행할 수 있도록 한다.
  - 즉, 프록시 객체가 선행작업을 수행하도록 한 것이다.



=> 그래서 엔티티에 final이 붙으면, jpa를 사용할 수 없다. 프록시 객체를 생성해야 하기 때문이다.(final은 상속을 못받음)

---

### em.detach(), em.remove()

- detach()
  - 1차 캐시에서 없애기
  - **쓰기지연 sql 저장소에도 관련 sql 전부 없애기**

---

### merge()

- merge()
  - 준영속 상태의 엔티티로, 영속 상태의 (새로운) 엔티티를 만드는 것.
  - 리턴 값이 있으면 엔티티를 반환받는것이고, 없으면 반환 못받는 것일 뿐이다. 엔티티를 만드는 것은 결국 같다
