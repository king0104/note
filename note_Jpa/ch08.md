## 1. 지연로딩과 프록시

#### 지연로딩

- 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법



#### 프록시

- 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체이다.

**프록시 기초**

em.find()

- 엔티티를 직접 조회하는 것
- 영속성 컨텍스트에 엔티티가 없으면, 데이터베이스 조회한다
- 실제 사용하던지, 사용하지 않던지 데이터베이스를 조회한다



em.getReference()

- 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루는 것
- 실제 엔티티 객체가 아니라, 프록시 객체를 반환하는 것.



**프록시 객체의 초기화**

- 프록시 객체에서, getName() 처럼 실제 사용될 때 데이터베이스를 조회해서, **실제 엔티티 객체를 생성**하는 것.

  - ```java
    Member member = em.getReference(Member.class, "id1");
    member.getName(); // 이때, 실제 엔티티 객체 생성 
    ```

- **프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다.** 프록시 객체가 초기화되면, 프록시 객체를 통해서, 실제 엔티티에 **접근**할 수 있다.



- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면, 프록시가 아닌 실제 엔티티를 반환한다.
- 영속성 컨텍스트가 없으면, 프록시 객체 초기화 불가능. 즉, 준영속 상태의 프록시를 초기화하면 문제가 발생한다.



## 2. 즉시로딩과 지연로딩

#### 1. 즉시로딩

- 엔티티 조회할 때 연관된 엔티티도 함께 조회한다

- ```java
  @ManyToOne(fetch = FetchType.EAGER)
  ```



< 예제 코드 >

```
Member member = em.find(Member.class,"member1");
Team team = member.getTeam();
```

- **em.find() 하는 순간 연관 엔티티도 함께 조회**
  - 멤버 : 실제 객체 / 팀 : 실제 객체
- member 테이블과 team 테이블 조회해야 하므로, 쿼리가 2번 실행되어야 한다. 하지만, JPA 구현체의 최적화로 인해 JOIN 쿼리를 사용하여 쿼리를 1번 실행시키도록 한다.

---

#### 1-1. 즉시로딩과 NULL 제약조건

- 즉시로딩 only
  - 두 테이블 조인 시, '외부조인' 사용
    - 한 테이블의 **연관 필드에 값이 없을 수 있기 때문**이다.



- **즉시로딩 + FK에 NOT NULL**

  - 두 테이블 조인 시, '내부조인' 사용 (성능 더 좋음)

  <FK에 NOT NULL 제약조건 걸기>

  1. DB의 테이블 상 외래키에 not null 제약 조건 걸기
  2. 코드 상에서 @JoinColumn에 nullable=false 걸기 (JPA에게 알려주기 위함)

---

#### 2. 지연 로딩

- 연관된 엔티티를 실제 사용할 때 조회한다

- ```java
  @ManyToOne(fetch = FetchType.LAZY)
  ```

  

< 예제 코드 >

```
Member member = em.find(Member.class,"member1");
Team team = member.getTeam();

team.getName();
```

- **em.find() 하는 순간 멤버는 조회하고, 팀은 조회하지 않는다**
  - 멤버는 실제 엔티티, 팀은 프록시 객체



















---

#### 영속성 전이

- 해결해야 할 문제 : 
  - 엔티티를 영속 상태로 만들어서 데이터베이스에 저장할 때, 연관된 엔티티도 모두 영속 상태여야 한다.

- 해결 방법 :
  - 하나의 엔티티와 관련된 모든 엔티티에 영속성 전이 적용.
  - cascade = CascadeType.ALL



