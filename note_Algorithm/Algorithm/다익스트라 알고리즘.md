## 다익스트라 알고리즘

![image-20210810171611052](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20210810171611052.png)

최단거리 테이블 : **출발 노드에서 다른 모든 노드로 가는 최단거리**를 적어둔 테이블 (DP의 메모이제이션)

### 구현

출발노드 : 1번 노드

최단거리 테이블의 모든 값 '무한'으로 초기화



1. 방문하지 않은 노드 중에서 **최단 거리가 가장 짧은 노드**를 선택한다. 

   출발 노드에서 출발 노드로의 거리는 0이므로, 처음에는 출발 노드가 선택된다.

   

2. 선택된 노드를 거쳐 다른 노드로 가는 비용을 계산한다.

   즉, 선택된 노드와 연결된 모든 간선을 하나씩 확인하면 된다.

   계산한 비용으로 최단 거리 테이블을 갱신한다.

   

다시 1번으로 돌아가 1,2번 과정을 반복한다.



### 구현 - 우선순위 큐 사용 ( - 표시 되어있는 것이 추가된 사항)

현재 노드에서 **최단 거리가 가장 짧은 노드를 선택하기 위한 목적**으로, 우선순위 큐를 사용하는 것이다.

- 비용이 적은 노드를 우선하여 방문해야 하므로, **최소힙**을 사용한다.

- **최대힙 사용** : 최소 힙을 최대 힙처럼 사용하기 위해 우선순위 큐에 넣을 때 우선순위 값에 (-) 를 붙여서 넣고, 나중에 우선순위 큐에서 꺼낸 다음 다시 (-)를 붙여서 원래의 값으로 돌리는 방식을 사용하기도 함.



출발노드 : 1번 노드

최단거리 테이블의 모든 값 '무한'으로 초기화

0. 우선순위 큐에 출발노드(1번 노드)를 넣는다.



1. 방문하지 않은 노드 중에서 **최단 거리가 가장 짧은 노드**를 선택한다. 

   ( 출발 노드에서 출발 노드로의 거리는 0이므로, 처음에는 출발 노드가 선택된다. )

   - 우선순위 큐에서 그냥 노드를 꺼내면 선택 완료
   - 꺼낸 뒤, **해당 노드를 이미 처리한 적이 있다면 무시**

   

2. 선택된 노드를 거쳐 다른 노드로 가는 비용을 계산한다.

   즉, 선택된 노드와 연결된 모든 간선을 하나씩 확인하면 된다.

   계산한 비용으로 최단 거리 테이블을 갱신한다.

   - **더 짧은 경로를 찾은 노드 정보(거리+노드 객체)들은 다시 우선순위 큐에 넣는다**

   

다시 1번으로 돌아가 1,2번 과정을 반복한다.



---

### 특이점

![image-20210810204846404](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20210810204846404.png)

![image-20210810204856113](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20210810204856113.png)



- PriorityQueue에 **객체**를 넣어 사용하려면, compareTo를 오버라이딩 해야지 우선순위를 정할 수 있다.
  - Node 클래스에 Comparable을 구현하였다.
  - 그 후, Comparable 인터페이스의 추상 메서드 compareTo를 오버라이딩 하였다.
    - compareTo : 바꾸는 메서드 라고 생각하자!



---

### Comparable & Comparator

#### "객체를 비교할 수 있도록 만든다"

내부에 존재하는 메서드인 compareTo, compare 은 **(비교 당하는 대상의)자리를 바꾸는 메서드** 라고 생각하자!!



- **java.lang.Comparable<T>**: 원소 스스로 다른 원소와 자신을 비교할 때 사용하는 방법입니다.

  1. 자기 자신과 매개변수를 비교한다.

  2. compareTo 메소드를 반드시 구현해야한다.

  

  - ***tip)*** 그렇기 때문에 여러분이 compareTo를 구현하거나, 이후 설명 할 compare을 구현 할 때 대소비교에 있어 이러한 Overflow 혹은, Underflow가 발생할 여지가 있는지를 반드시 확인하고 사용해야 한다. 

    특히 **primitive 값에 대해 위와 같은 예외를 만약 확인하기 어렵다면 <, >, == 으로 대소비교를 해주는 것이 안전**하며 일반적으로 권장되는 방식이다.

     



- **java.util.Comparator<T>**: 두 개의 원소 대소 비교를 **비교자**가 판단하는 방법입니다.

  - 즉, 객체 자체와는 상관 없이 독립적으로 매개변수로 넘겨진 두 객체를 비교하는 것이 포인트다.
  
  - 위에서 보았듯이 Comparator를 통해 compare 메소드를 사용려면 **결국에는 compare메소드를 활용하기 위한 객체가 필요하게 된다.**
  
  - 위에서 보았듯이 Comparator를 통해 compare 메소드를 사용려면 결국에는 compare메소드를 활용하기 위한 객체가 필요하게 된다.
  
    무슨 말인가 하면, a, b, c 객체가 생성되어있고, 이들을 비교를 하고 싶다면 어느 한 객체를 통해 compare메소드를 사용해야한다는 것이다.
  
    즉, 다음과 같은 상황이 온다는 것이다.
  
    ![image-20210810212049497](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20210810212049497.png)
  
  - 즉, 우리가 원하는 것은 Comparator 비교 기능만 따로 두고 싶은 것이다.
  
  - Comparator 기능만 따로 두고싶다면 어떻게 해야할까?
  
    답은 매우 간단하다.
  
     
  
    **"익명 객체(클래스)를 활용한다"**
  
  ![image-20210810213010120](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20210810213010120.png)
  
  
  
  분명 앞서 본 상속받아 ChildRectangle 클래스를 만든 것과 같지만, 이 코드는 이름이 정의되어있지 않고, anonymous라는 이름으로 객체만 생성되어 있다.
  
  이렇게 클래스 이름으로 정의되지 않는 객체를 바로 익명 객체라 하는 것이다.
  
  
  
  이는 거꾸로 말하면, 이름이 정의되지 않기 때문에 특정 타입이 존재하는 것이 아니기 때문에 **반드시 익명 객체의 경우는 상속할 대상이 있어야 한다는 것이다.**
  
  
  
  이 때, 상속이라 함은 class의 extends 뿐만 아니라 interface의 implements 또한 마찬가지다.
  
  
  
- 우리가 원하는 것은 무엇이었을까? 바로 Comparator 의 기능만 사용하고 싶은 것이다. 즉, Comparator의 구현을 통해 compareTo 만 사용하고 싶은 것이라는 뜻이다.

   

  앞서 익명객체에서 설명한 것을 적용해보자.

  분명히 Comparator라는 **interface**는 존재한다. 이는 구현(상속)할 대상이 존재한다는 것이다. 이는 **익명객체로 만들 수 있다는 것**이다.

   

  **즉, 이름은 정의 되지 않지만, Comparator을 구현하는 익명객체를 생성하면 되는 것**이다.





- 자. 이렇게 외부에서 Comparator을 구현하는 익명객체가 생성되었기 때문에, Student 클래스 내부에서 우린 Comparator을 구현해줄 필요가 없어졌다.

  

  즉, 이 전에 a.compare(b, c) 이런식이 아니라, 위에서 생성한 **익명객체를 가리키는 comp 를 통해 comp.compare(b, c)** 이런 식으로 해주면 된다는 것이다.

![image-20210810215221433](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20210810215221433.png)





익명 객체를 사용하면 좋은 점이 하나 더 있다. 다시 한 번 복기해보자. 익명 객체는 이름이 정의되지 않은 하나의 새로운 클래스와 같다고 보면 된다.

 

클래스를 상속(구현)할 때, 이름만 다르게 하면 몇 개던 여러개를 생성할 수 있듯이, 익명 객체 또한 마찬가지다. 다만, 이름이 없을 뿐이라는 것이다.

 

즉, 익명 객체를 가리키는 변수명만 달리하면 몇 개든 자유롭게 생성할 수 있다. 위 예제에서는 학급을 기준으로 대소 비교를 했지만, 만약 나이를 기준으로도 대소 비교를 하고 싶다면 다음과 같이 하나의 또다른 익명 객체를 생성 할 수 있다는 것이다.

 

![image-20210810215327525](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20210810215327525.png)

![image-20210810215338221](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20210810215338221.png)

![image-20210810215346144](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20210810215346144.png)



즉, compare 혹은 compareTo를 사용하여 객체를 비교 할 경우 **양수가 나오면 두 원소의 위치를 바꾼다는 것**이다.

그러면 {1, 2, 3} 으로 오름차순으로 정렬 될 것이다.

그럼 규칙을 일반화 할 수 있다.

 

**[두 수의 비교 결과에 따른 작동 방식]**

**음수**일 경우 : 두 원소의 위치를 **교환 안함**

**양수**일 경우 : 두 원소의 위치를 **교환 함**



---

### 사용하는 방법

그러면 이제 우리가 만든 comp 익명 객체를 사용하여 정렬할 수 있도록 해야한다.

"그러면 Arrays.sort()에 어떻게 Comparator 익명객체를 기준으로 정렬을 시키는 것이죠?" 라고 물을 수 있다.

 

이 부분은 걱정 할 것이 없다. Arrays.sort()에는 단순히 배열만 파라미터로 받는 것이 아니라 Comparator 또한 파라미터로 받기도 한다.

 

즉, 우리가 쓸 메소드는 다음과 같다.



![image-20210810215720634](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20210810215720634.png)
