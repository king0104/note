### 다익스트라

- 음수 간선이 존재하지 않을때
- 특정 노드에서 다른 모든 노드로의 최단거리(최소비용)를 구하고 싶을 때.

---

### 코드

#### 1. 필요한 것

- INF
- import heapq

```python
import heapq
INF = int(1e9)p
```



1. graph
2. distance 1차원 배열

```python
graph = [ [] for _ in range(v+1) ]
distance = [INF]*(v+1)
```

---

#### 2. 핵심 로직

- graph 만들기

```python
for _ in range(e):
    a,b,c = map(int,input().split())
    # a노드에서 b노드로 가는 비용 : c
    graph[a].append((b,c))
```

- dijkstra 함수

  - 출발 노드로 만드는 초기 작업
    - q만들기
    - q에 (o,start) 푸시하기 

  ---

  1. 최단거리 테이블에서 최단거리가 가장 작은 노드를 선택한다

     (* 최단거리 테이블 : (현재 시점 기준으로) 시작노드에서 해당 노드로 가는 데 걸리는 최소비용을 기록해둔 테이블)

     1-1. 선택한 노드에 대해 최단거리가 이미 결정되었다면, 무시한다.
  
     ```python
     while q:
         # 1. 최단거리테이블에서 최단거리가 가장 짧은 노드를 선택
         # dist랑 distance[now] 랑 차이점이 뭐지..?
         dist, now = heapq.heappop(q)
     
         # 1-1. 선택한 노드에 대해 최단거리가 이미 결정되었다면, 무시한다.    
         if distance[now] < dist:
             continue
     ```
  
     
  
  2. 선택한 노드를 거쳐, 다른 모든 노드로 가는 비용을 계산하고, 갱신 + heapq에 푸시
  
     ```python
     # 2. 선택한 노드를 거쳐, 다른 모든 노드로 가는 비용을 계산 & 갱신 + heapq에 푸시
     for i in graph[now]:
     	cost = dist + i[1]
     
     if cost < distance[i[0]]:
     	distance[i[0]] = cost
     	heapq.heappush( q, (cost, i[0]) )
     
     	# i[0], i[1]은 그래프의 원소에 대한 것
     	# 그래프는, (연결된 노드번호, 비용) 으로 구성되어있음!!
     
     	# tip) heap에 들어가는 튜플과 아예 다른 것이므로 별개로 생각할 것.
     ```
  
     

#### 코드상 참고사항

- 출발 노드로 초기작업을 한다. 그래서, distance[출발노드]는 0이 아니라, INF가 되어있을 것이다. 왜냐하면 출발 노드는 거리가 0임을 이미 알고있어서, 우리가 distance배열에 0으로 바꾸는 작업은 하지 않기 때문이다. 그래서, 출발노드에 대해 distance배열을 초기화 하고 싶다면, 그냥 distance[출발노드] = 0 으로 직접 초기화해버리자.

  - ```python
    dijkstra(k)
    distance[k] = 0 # 다익스트라 돌리고, 출발노드에 대해서 최단거리테이블은 직접 초기화하기
    ```

- 코드상 i[0], i[1]의 의미를 정확히 알자. graph의 원소임을 명심하자! (heapq의 원소가 아님)

  - i[0] : (now 노드와) 연결된 노드 번호
  - i[1] : 비용

  

#### 이 예제 보면 완벽 이해

- 알고리즘 7주차 : 1976_최소비용구하기

- 알고리즘 7주차 : 1753_최단경로