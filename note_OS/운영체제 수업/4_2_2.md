지금까지는 프로세스상태다섯 개 중에서 준비상태 실행
상태대기상태 등 세 가지를 중심으로 설명했는데요

자 그럼 이제 프로세스에 종료에 대하여 이야기 해보겠습니다

프로세스가 종료되었다 라는 것은
메인 함수 끝까지 도달하여 리턴이 일어났다거나
그렇지 않다면 프로그램 코드 어느 곳에서 exit호출되었거나
또는 다른 프로세스가 abort()를 시켰거나
한다는 의미입니다

**![image-20220330152654913](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330152654913.png)**

먼저 **시스템 호출을 통해서**
**커널에게 자신의 종료를 프로세스가 요청했다**
그 경우를 한번 살펴봅시다

 exit() 호출되었다 해도 프로세스는 그냥 막 바로 종료되면 안 됩니다
**wait() 상에 있는 부모 프로세스에게 종료라는 이벤트를 보내줘야만 합니다**

바로 전 슬라이드에 대해서 쉘이 방금 전
수행 시킨 명령에 수행이 끝났다는 것을 알고
그때서야 wait()에서 빠져나올 수 있었던 것도
바로 이러한 종료라는 사건을
이벤트로 알려주었기 때문인데요

자 그런 의미에서 아무것도 하지 않고
막 바로 종료과정을 거쳐서는 안 된다
그런 것입니다 자 그런데요

만약 부모 프로세스가 wait()상태에 있지 않고 있었다면
즉 **자식프로세스 wait()이 부모 프로세스 wait() 보다 먼저 일어났다**면 어떻게 될까요
시분할 시스템에서는 서로의 수행 속도 상의 차이가 생길 수 있기 때문에
얼마든지 일어날 수 있는 상황입니다

자 이런 경우 사실 그냥 끝나도 되겠지만
프로세스종료시 **exit code코드**라는 것이 있습니다

즉 그냥 exit() 시스템 콜을 호출하는 것이 아니라
예를 들어 무슨 문제가 있어서 이 일어날 경우에는 예를 들면
exit(-1) 이런 식으로 **마이너스 일이라는 코드**를 넘겨주게 되는 것이
일반적인 경우라 이거죠

물론 정상적으로 끝났을 때는 0이나 또는 1 양수를 넘겨주겠죠

또는 끝날 때 어떤 상태를 알려주기
위해서 **약속된 코드 값**을 넘겨주게 되는 경우도 있겠죠



자 **일반적으로 부모 프로세스는 이 값을 얻기 위해서 wait()를 한다 해도 과언이 아닙니다**

자 그런데 그냥 자식프로세스가 끝나버리면 
이 코드가 날아가게 되겠죠

자 이러한 현상을 방지하기 위해서
자식프로세스가 먼저 엑시트되면
주소공간과 그때까지 할당된 자원들
**즉 사용자 문맥과 그때까지 할당된 각종 자원들은 다 없어질지라도**
**pcb는 그대로 유지한다**

자 이렇게 다 없어지고 pcb 만 남은 상태
그것을 바로 **좀비상태**라고 부릅니다 자
이렇게 좀비상태로 잠시 있어야 된다
언제까지냐
exit code 를 wait 하는 프로세스들이 갖고
갈 때 까지는 이렇게
좀비상태로 적어도 있어야 된다 이 뜻입니다





자 **abort()**인 경우는 부모프로세스가
자식프로세스를 강제로 종료시킬 때 사용되는 거죠

즉 다른 프로세스에 종료를 요청하는건데
사실은 부모 프로세스만 할 수 있다

쉘에서 어떤 명령어수행이 끝나지 않고 계속 돌고 있다면
여러분 어떻게 합니까 컨트롤 c를 하죠

바로 그때가 쉘이 현재 그 명령어를 수행시키고 있는 자식
프로세스에게 abort()를 시키는 것이 되는 것입니다

자 **abort()를 하려면 자식프로세스의 pid 가 필요**할 겁니다
아마 이 때문에라도 **포크 시 부모프로세스에게**
**자식프로세스의 pid를 리턴**해주는 것으로 약속을 한 것이다
이렇게 생각이 됩니다

즉 포크 리턴값이 부모에게는 자식프로세스 아이디 인 이유
그것이 바로 이러한 이유가 되지 않을까
이렇게 생각을 해볼 수 있는 것입니다

---

2

![image-20220330152636047](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330152636047.png)

방금 전 설명한 exit()과  wait()의 관계를
다시 한번 그림으로 그려 본 것입니다

먼저 페어런트 프로세스가 fork를 해서
차일드프로세스 를 만들면 그 차일드프로세스는 exec를 해갖고
자기만의 프로세스가 이제 되는 겁니다

자 그런 후 차일드프로세스가 다 돌고
exit()을 어느 순간 하게 되면 exit_code를 넘기게 되는데
**exit code가 어디저장되냐면**
**차일드프로세스의 pcb위에 저장**이 되게 된다

그러면 페어런트 프로세스가 먼저 돌던
나중 돌든 이 wait()을 수행하게 되면 

**wait()수행할 때, 차일드가 기록해놓은 exit code를 인출**해 가게 된다

그리고 그에 따라서
그 이후에 패런트 프로세스가 조치를 하게 된다
그 거고요



자 그**렇게 엑싯은 했지만**
**다른 것들은 다**
**없어져도 이 pcb만큼은 잠시나마 있는 상태그것이 바로 좀비상태**다
이렇게 이야기했습니다