#### 하나의 상태에 여러번 도달할 수 있을 때는(= 하나의 상태에 다양한 경로로 도달할 수 있을 때에는),

- **"for문 + 업데이트"!!!!!!!!!!!!!**
- 이것을 dp적 사고라고 부르는 이유
  
  1. 하나의 상태 = dp[n]
  
  2. 하나의 상태를 업데이트 하는 식 = 점화식

---

<예시 - 2056_작업> 

(참고로, 위상정렬에서 모든 작업이 끝나는 최소시간을 묻는 문제)

- ```
  dp[next] = max(dp[next],dp[now]+t[next])
  ```

  - dp는 어떤 상태값을 저장해두고 있는 것이다.
    - 현재 푸는 문제에서는, dp[n] = n번째 노드까지 오는데 걸리는 시간 을 의미한다.
  - n번째 노드까지 오는데 걸리는 시간은  다양하다. 1 to n, 2 to n, 5 to n 등 여러개의 이전 노드가 있을 수 있다. 위상정렬에서는, 이전 작업이 모두 수행되어야지 다음 작업을 수행할 수 있기 때문에,  1,2,5 노드를 거쳐오는 시간 중 가장 긴 시간이 실제로 dp에 들어갈 수 있다.
  - 이를 찾기 위해, 우리는 1 to n, 2 to n, 5 to n을 한번씩 확인하면서 최댓값을 찾아야 한다.

  

  - **이건 "for문 + 업데이트" 유형과 같다. for문으로 완전탐색을 하면서, 정답을 업데이트 해나가는 것이다**.

    - ```python
      # "for문 + 업데이트" 코드의 대표적 예시
      ans = 0
      for v in nlist:
      	ans = max(ans, v)
      ```

      

​			