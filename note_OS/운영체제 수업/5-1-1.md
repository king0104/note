생성 상태라는 것은 프로세의 pcb와 사용자
주소공간 이 마련된 상태를 뜻하는 것인데요
자 이 뜻을 이해하는 것도 중요하겠지만
프로세스가 생성되는 과정을
이해하는 것이 더 중요합니다



기본적으로 프로세스 생성을 위한 시스템 콜은 포크fork입니다
이와 반대로 종료를 위한 시스템 콜은 ex it겠죠
나중에 설명하도록 하겠고요
자 프로세스에 생성
은포크시스템 콜에 의해서 이루어진다 바로 이런 건데요
자 어떤 이미 의 프로세스를 하나 놓고 볼 때
그 프로세스는 다른 프로세스 하나가 포크시스템 코를 호출함으로써
커널내에서 와 이를 위한 사용자 수소공간이 마련된다
바로 그 뜻이죠
이때 생성을 시작시킨 프로세스를 부모 프로세스
즉 프로세스라 하고 생성된 프로세스를 자식프로세스
즉 프로세스라고 합니다
여기서 분명한 것은 하나의 프로세스를 놓고 볼 때
그 프로세스의 부모 프로세스는 단 하나라는 것이죠
자 그렇다면 부모의 부모
또 그 부모의 부모 이렇게 거슬러 올라갈 수 있겠고
그러다 보면 최초의 프로세 스가 나오겠죠 자
오른편에 있는 그림이 바로 그 예인데요
자 그림에 예시를 보면 루트프로세스가 있고요
그 프로세서시작해서 시스템 자원의 필요한 프로세스들이 만들어지겠고요
자 사용자 프로세스에 시조라 할 수 있는 있니
프로세스가 만들어지면 로그인 프로세스 를 만들어 갖고
각 사용자들의 로그인을 받게 되죠
자 로그인이 되면 프로세스가 만들어집니다
자 그 프로세스가 만들어져서
각종 명령어를 사용자 로부터 받게 되고요
그 명령어를 통해서
다양한 응용 프로그램에
프로세스들이 프로세스로 생겨나게 되는 겁니다
자 어찌보면 우리 눈에 주로 뜨있는 프로세스들 라든지
또 우리가 주로 사용하는 프로세스 들은 사실 있니
프로세스로부터 시작됐지만
더 올라가면 루트프로세스로부터 시작된 것이고요
가까이는 프로세스로부터 생겨난 것이라고 보면 되겠죠
자 그런 과정이 지속되다 보면 어느 한순간시스템
네 프로세스관계도가 이와
같이 거대한 트리가 되어 있을 겁니다
자 그럼 포크시스템 콜에 대해서 설명을 하겠습니다 이 포크함수
는 매우 독특한 함수라고 볼 수 있겠습니다
즉 오크라는 시스템 콜은 부모
프로세스에 의해서 호출이 되겠죠
하지만 포크에 의해서 자식프로세스가 생겨나면
포크함수의 리터는 부모프로세스와 자식
프로세스모두에게 일어난다
자 포크로부터의 리터는 부모프로세스와 자식
프로세스두 곳으로 리턴이 일어난다
이런 면에서는 매우 독특한 함수라는 것이죠
대한 이 두 리턴의 리턴값이 서로 다르다는 겁니다
즉 부모프로세스에 있어서의 포크리턴값은 새로 만들어진 자식프로세스에
고유번호
즉 자식프로세스에 가 리턴이 되고요
반면에 자식프로세스에 있어서의 포크리턴값은 0이
리턴이 되는 겁니다
자 이게 무슨 뜻인가
왜 그렇게 정했는가 하는 것은 잠시 후
예제를 보면 알 수 있을 겁니다
일단 여기서는 포크를 하는 순간
같은 프로그램을 수행하는 가상적인 가 하나 만들어져서
따로 돌기 시작한 것이다 라고 생각하면
이해가 쉬울 것 같습니다
다시 말해서 동일한 프로그램을 수행하는
가상적인 가 하나
더 만들어져서 따로 하나가 실행이 시작되게 된 것이다
그것이 차일도 프로세스다 이렇게 생각하면 쉬울 것이라는 뜻입니다
자
그럼 예제를 하나 보도록 하겠습니다
자 예 지를 보는 데 있어서
포크라는 시스템 콜은 프로세스를 복제하는 시스템이다
이걸 잘 기억해 두고 예제를 같이 보면 좋겠습니다 자
여기 네 줄 짜리 프로그램이 있습니다
네 줄 짜리 프로그램이 현재
프로세스 가 되어서 수행되고 있는 거죠
자 프로이 프로그램에는 저녁 변수가
아이가 저녁 변수가 하나 있고
라는 저녁 변수가 현재 있습니다
아이는 영으로 초기화됐고요
자 먼저 프린트F 가 수행되면서
아이가 하나증가해서 일이 됐고요
그 다음에 포크라는 시스템 코를 수행을 했습니다
지금 딱 그 순간이라고 합시다
그러면 그 순간 이 프로세스 가 하나 복제가 되는 것입니다
아까 그 복제를 잘 기억해달라고 이야기 했었죠
자 포크를 수행하는 순간
프로세스가 복제가 돼서 자식프로세스가 하나 생겨난다
그걸 프로세스 비라 하겠습니다
이제 프로세스와 프로세스비두 개가 있는 겁니다
자 그렇게 되면 이미 프로세스가 둘이 되었기 때문에
각자 포크의 리턴이 생겨나야 되는데
포크리턴도 각각 일어난다
그럴 수밖에 없겠죠
프로세스가 둘이 되어서
프로세스가 돌아야 되기 때문에요
그래서 리턴이 양쪽에서 일어난다 이겁니다 자 그런데요
그 리턴값이 서로 다르다는 거지
포크의 약속입니다 자 어떻게 다르냐
즉 왼편부터 보면요
오른쪽에 새로 만들어진 자식프로세스인
프로세스비의 값이 바로 리턴이 됩니다
차일드프로세스에 값이 부모
프로세스에 포크리턴값으로 리턴이 된다
바로 그 것이고요
자 오른쪽에 있는 자식
프로세스에게로 의 는 그냥 영이 리턴됩니다
자 만약에 자식프로세스가 부모
프로세스에 를 얻고자 할 때는 어떻게 얻어야 되냐 하면 갯
페어렌트 이러한 시스템콜이 따로 있습니다
이런 것들을 이용해 내면
페어런트 프로세스에 값을 얻을 수 있죠
자 그렇기 때문에 차일드프로세스에게 영리리턴됐다고 해서
큰 문제가 되는 것은 아닙니다
자 그럼 왜 이렇게 자식프로세스에게는 영을 리턴해주고
페어런트 프로세스에게는 자식프로세스에
아이들을 리턴해주기로 약속을 했느냐
자 그렇게 약속한 이유는
잠시 후에 다른 예제를 보면서
설명을 하도록 하겠습니다
자 그렇다면 여기 저녁 변수가 양쪽 있게 되는거죠
만 보더라도 저녁
변수가 양쪽에 있게 됩니다 이 양쪽에 있는 저녁 변수는
같은 변수일까요 다른 변수일까요
네 서로 변수명은 같아도
포크이후에는 다른 프로세스 에 있는 다른 변수입니다
같은 변수라면 문제가 되겠죠
자 어떻게 해서 다른 변수일까요
그럼 그것은 사용자 수준
문맥에 전역 변수 부분인 데이터 부분이 복제가 되어서
분리되었기 때문입니다
여기서 사용자 문맥에 텍스트는 공유하되
데이터 부분과 스텝부분은 그 공간을 별도로 생성 했다
그것이 포크가 한 역할인 것입니다
그래서 요데이터 부분이 별도로 생겨났다
때문에 데이터 부분에 들어가는 전역
변수들도 다른 것이 된 거죠
마찬가지로 도 프로세스가 별도로 하나 생겨났기 때문에
차일드프로세스 를 위한 도 새로 생겨난 겁니다
자 이렇게 묻맥이 복제되는 것에 대해서는 잠시 후
다시 한번 자세히 설명을 하겠습니다
그럼 아이도 마찬가지로 다른 변수겠죠
따라서 편에 플러스 플러스아이가 먼저 수행되고
오른편에 플러스 플러스아이가 나중에 수행되던
또는 오른편에 있는 플러스 플러스아이가 먼저 수행되고
왼편에 있는 것이
나중에 실행되던 모두 값은 양쪽에 이 기가 됩니다
만약에 이것이 같은 변수였다
그러면 어느 한쪽이 다른 한쪽이 삼 이 되겠죠
나중에 실행된 것이 삼 이 됐겠죠
그래서 프린트를 하더라도
한쪽은 이 한쪽은 살이렇게 돼야 되는데
그렇지 않다 이거죠
양쪽 다 이가 프린트된다 바로 이겁니다
자 한마디로 정리하자면
포크를 하게되면 자식프로세스 를 위한 사용자
문맥과 커널수준 문맥이 별도로 만들어진다
그렇기 때문에 저녁 변수에 이름만 갖고
실질적으로는 다른 변수가 된다 이런 이야기입니다
자 그럼 포크의 리턴값이
서로 다르도록 약속을 했다고 했고
자 페어런트 층에는 새로 생겨난 차일드프로세스에 가
리턴값이 되고
차일드측으로는 리턴값은 0이 되도록 약속을 했다
이렇게 이야기를 했는데요
왜 그랬을까요
자 그것은 바로 동일한 프로그램
이렇게 하나의 프로그램으로 부모
프로세스와 자식 프로세스가 서로
다른 코드 블록을 수행할 수 있도록 하기 위해서입니다
다시 말해서 이 부분은 차일드프로세스가 수행하고
코드에 이 부분은 부모 프로세스가 수행하는 부분으로
별도로 프로그램 하되
같은 프로그램 내에
프로그램 하도록 하기 위해서였다는 거죠
자 이 예제를 한번 다시 한번 봅시다
자 포크의 리턴값에 대해서 조건문을 만들어서
그 리턴값이 영인지 체크하면
트루에 해당하는 블록에는
자식프로세스가 수행할 코드를 넣을 수가 있겠죠
그것이 바로 이 부분이라는 거죠 영을 체크했으니까요
자
엘스 블록에는 그럼 어떻게 할까요
엘스 블록에는 한번 영 이 아닌가를 한번 체크는 해주고
영이 아니라는 것은 바로
이쪽은 페어런트가 수행할 부분이라 이 뜻이죠
그리고 여기다가 페어런트가 수행할 코드 를 넣으면 된다
이거죠
즉 하나의 프로그램 이지만
두 프로세스가 다르게 수행할 수 있도록
코드를 짤 수 있게 하자 이런 취지였다는 거죠
자 그렇다면요
자 프린트문이 여기에도 있고 여기에도 있고
두 군데 있습니다 지금 자 어느쪽프린트문이 수행될까요
이제는 좀 우스운 질문이죠
사실 두 프로세스가 각각의 해당 부분을 수행시키기 때문에
두 군데프린트믄 모두가 실행되겠죠
물론 서로 다른 프로세스 에 의해서 수행되는 겁니다
자 그래서 여기서는 를 사러 놓고
프린트를 했으니까 사과 프린트대가 되겠고
여기서는 A 를 오루 놓고 프린트를 했으니까 오가 프린트되겠죠
두 군데에서 다르게 프린트가 되는 겁니다
좀 더 봅시다 자
부모 프로세스가 수행하는 조건문 블록끝에 웨이트 가 있습니다
이요 자
그것은 자신이 만든
자식프로세스가 엑시트종료되기까지 기다리겠다는 시스템입니다
따라서 자식프로세스가 수행하는 족
권문블로그에 끝에 있는 엑시트가 실행이 되면
엑시트가 실행이 되면 자식프로세스가 종료되겠고
그렇게 사십 프로세스가 종료되면
부모 프로세스에 트가 풀려나겠죠
그래서 조건문의 다음
코드인 두 썸싱 이 그제서야 실행이 될 것입니다
즉 페어런트 프로세스가 여기 에 먼저 도달하면
자식 프로세스가 나중에라도
엑씻을 하기까지 기다리게 되겠고요
만약에 자식프로세스에 먼저 수행됐다면
부모 프로세스에 트는 즉시 빠져 나오겠죠
어쨌건 이 두 개가 다 끝나야지만이 푸문의 다음
라인인 2썸증이라는 코드를 그제서야 수행하게 되겠죠
자 그렇다면 이 족
원문다음에 두 썸싱 부분은 몇 번 수행될까요
이제는 자식 프로세스가 없음 으로
오로지 부모 프로세스만 그 부분을 수행하게 되겠죠
따라서 이 부분은 한번 수행이 됩니다
참고로 이 퀴즈를 잠시 보기 바랍니다
자 이러한 왼편에 코드가 있다고 합시다
직접 한번 돌려봐도 좋겠는데요
총 몇 개의 프로세스가 생성되어서 끝나지 않은 채
맨 끝에 있는 이 화 일문들을 돌리고 있을까요
코드 상으로는 포크이 두 번이지만
처음 프로세스를 포함해서
사실 네 개의 프로세스가 생성되어 돌고 있을 겁니다
자 오른쪽에 그림을 보면 이해가 될 것인데요
첫번째이렇게 시작된 메인
프로세스가 하나의 있을 거고요 이 첫번째 프로세스가 돌면서
폭음은 두 개를 수행시키면
프로세스가 총 세 개가 될 겁니다
그런데 이 두 포크호출중
첫번째 포크로 생성된 자식프로세스가
그 다음 줄에 있는 포크를 또 한번 수행하게 되겠죠
그렇기 때문에 한 프로세스가 더 만들어지게 돼서
총 4 개의 프로세스가 생성되어 돌게 됩니다
여러분들도 한번 실제로 프로그램을 해보고
확인해보면 좋을 것 같습니다
자 그럼 포크의 동작의 특징을 이해하셨을 겁니다
그럼 포크로 인해서
커널내부에서 벌어지는 일들을 좀 더 자세히 이야기 해보겠습 니다
먼저 포크에 의해서 새로운 프로세스가 만들어졌다
바로 그것은 커널레의 도
새로 만들어지게 됐다는 것이고요
부모 프로세스에 값들 중에
많은 부분이 그 새로 만들어진 로
초기 값으로 복제가 됐다
그런 의미가 또 되겠습니다 자
그러한 과정을 특별히 클로닝이라고 부릅니다
프로세스고유번호 같이 서로 달라야 되는 부분이 있기 때문에
서로 완전히 똑같지는 않고
거의 똑같은 것을 만든다는 뜻에서
클로닝이라고 부른다는 것이죠
자 어찌보면 이것을 상속이라고도 볼 수 있겠는데요
자 이를 통해서 부모가 사용하던 파일 이라든지
나중에 배우게 될 동기와 자원
또 우선순위정보 이런 것들을 상속받게 됩니다
물론 한 프로세스가 너무 많은 자식
프로세스를 생성 하여
과중한 부활을 발생시키는 것을 방지하기 위해서
부모프로세스자원의 일부만 상속되도록 할 수도 있겠죠
또한 커널수준 문맥의 핵심인 특수레지스트와
법령레지스트의 경우
부모 프로세스에 값이 자식프로세스의 초기 값으로 복제는 되지만
각자 수행이 진행되기 때문에
즉시 그 값들이 달라지게 되겠죠
자 그렇다면 사용자 공간에 있는 사용자 수준
문맥은 어떻게 될까요
먼저 부모 프로세스에 사용자 수준 문맥이 자식
프로세스 를 위한 사용자 수준은
문맥으로 복제되어 가는 것은 맞습니다
하지만 여기서 텍스트
영역은 두 프로세스가 공유를 한다
그리고 를 포함해서 데이터 영역은 별도로 복사되어서
따로 만들어진다
자 그런 것입니다 여기서
왜 텍스트 영역은 복제를 해주지 않았을까요
그것은 방금 전 예에서 보았듯이
두 프로세스가 같은 코드를 수행하고 있기 때문에
그 코드 영역은 갖고
또 코드 자체는 변경 될 일이 없기 때문에
또는 변경되어서는 안 되는 부분이기 때문에
굳이 따로 갖고 있을 필요가 없기 때문입니다
자 이렇게 데이터 영역과
스영역이 모두 따로 복사가 되는 건데요
텍스트 영역 을 제외하고요
자 이렇게 텍스트 영역을 제외한 데이터 영역과
스영역이 모두 따로 복사되는 그런 형태의 프로세스
그것을 바로 해 비웨이트 프로세스라고 부릅니다
참고로 나중에 배우게 될 쓰레드
는 스택영역만 따로 복사하기 때문에
상대적으로 스레드 는 라이트프로세스라고도 부릅니다
그것은 참고하시고
나중에 또 한번 설명하도록 하겠습니다
방금 전에 언급한 회프로세스가 포크되는 과정을
다시 한번 개념도로 정리해보았습니다
자 프로그램 코드
는 아래에 있는 바와 같고요 이 프로그램을 컴파일하여
얻은 바이너리 코드가 점아웃 이라고 합시다
라는 를 에서 수행을 시키면
네 번째 라인이 수행될 때 호크가 일어나게 되겠죠
그럼 그 순간 스테데이터 영역
바로 스텍과 힙과 데이터 영역은 복제가 되겠죠
이렇게 복제가 돼서 별도로 만들어지겠죠
그렇지만 이 텍스트 부분은 공유를 한다
바로 그것이 되겠고요
자 여기서 유념할 점은 자
요데이터 영역이 복제가 되어도
포크리턴값을 보관하는 이 변수는
즉시 다른 값이 되겠죠
그래서 왼쪽에 있는 페어런츠
에 있는 차일드프로세스에 은 오백
오십오를 갖게 되는 거고
오른쪽에 있는 차일드프로세스에
변수에는 영이 들어가 있는
그런 상태가 바로 포크가 일어난 직후에 상태다
이렇게 보시면 되겠습니다
그런데요 이 시점에서 큰 의문점이 생길 겁니다
자식프로세스는 꼭 저렇게 만 생성되는 것인가
자 페어런트 가 갖고 있던 큰 코드 속에 일부분으로서의 자식
프로세스용 코드가 담겨 있는 그런 형태야만 되는가
자 그렇다면 시스템이
모든 프로그램은 하나로 되어 있어야 한다는 것인데
그럴 리는 없겠고 그런 등등의 이제
의문점이 생길 겁니다
자 그래서 그러한 의문에 대한 답을 지금부터
하려고 합니다
자 그 질문에 대한 답은
라는 시스템 의 답이 있습니다
자 는 파라미터의 구성을 다양하게 하는
비슷한 함수 들이 있어서
편의에 따라 사용하면 되는
이러한 것들을 모두 엮어서 라고 부르죠
대표적인 함수가 라는 겁니다
는 사용자 수준의 문맥즉
사용자 공간에 내용을 완전히 새로운 것으로
대체시키는 기능을 합니다
자 디스크 에 있는 프로그램을
로딩에서 새로운 프로세스로 탈바꿈시키기 위한
그런 역할을 한다 이거죠
자 그래서 라는 것은 자식프로세스가 생성된 후
자신의 주소공간에 디스크 로부터
새로운 프로그램을 적재하여
수행시키는 것이 바로 의 역할입니다
그렇기 때문에 워크를 한 후에는 바로 를 하는 것이
통례죠
즉 다시 말해서 의 정보 및 부모
자식 관계등은 그대로 유지한 채 포크된 자식프로세스에 텍스트
데이터스트 등 사용자 수준 문맥의 모든 부분을 교체해버리고
새로운 사용자 수준 문맥을 탄생시키는 것
그것이 바로 입니다
이것이 무슨 말인지 좀 감이 안 잡힐 텐데요
예제를 보도록 하겠습니다
여기 왼편에 방금 전
포크에 의해서 생성된 프로세스가 하나 있습니다
자 이것이 이제 프로세스비가 되겠죠
자 이 프로세스 가 이렇게 수행되면서 프린트문을 수행한 다음에
그 다음에 을 수행한다고 한번 봅시다 자
이라는 것은 한 함수죠
자 그 이라는 시스템 호출을 실현하면
그 즉시 팔아 메트로들어있는 빈밑에 있는 S 라는 실행 파일
우리 라는 COM 자주 쓰지 않습니까
그것도 실행 파일 있겠죠
그 실행 파일 의 위치가 빈미터입니다
자 그 파일을 어디다가 갖고 오냐 하면
프로세스비의 사용자 수준
문맥에다가 바로 를 시켜버리는 거죠
자 그리고 나서 바로 이 프로세스에
커널문맥에 해당하는 특수레지스터인 프로그램 카운터
그 값을 바로 새로 로딩한 LS
라는 실행파일이 시작 주소로 세팅을 하는 겁니다
그렇게 되면 어떻게 됩니까
자 이 사용자 수준
문맥에 내용이 S 라는 것으로 다 바뀌었기 때문에
그리고 그레스 라는 실행파일에 시작 시점으로
프로그램 카운트를 세팅했기 때문에 이 프로세스가 돌때는
이제는 이거 다 없어지고
S 라는 프로그램이 돌기 시작하는 거겠죠
결국 이전에 수행되는 프로세스에
내용은 완전히 사라지고
빈 밑에 S 프로그램이 프로세스로 올라와서
실행이 된다는 겁니다
단는 원래 것을 물려봤습니다
그 뿐 아니라 코너는
원래 있던 것을 그대로 사용하게 되겠죠
사용자 수준의 문맥을 로다 바꿔치기한 것이고요
그 사용자 수준의 문맥에 해당하는 프로그램을 수행하다 보면
에 있는 각 종
커널수준의 문맥은 그 이후부터
그에 맞게 바뀌어나가게 되겠죠
하지만 이라는 자료구조는 원래 있던 것을 그대로 사용한다
바로 이뜻입니다
자 요약을 하자면 이렇게
자신의 프로세스내용을 완전히 덮어어버리는 것
그것이 바로 이라는 것입니다
자 이것을 포크하고 같이 연계해서 사용하면 자
차일드프로세스는 완전히 새로운 내용이
프로세스로 만들어 나갈 수 있다
바로 이 뜻입니다 자
그 이야기를 조금 더 자세히 하겠는데요
보통의 경우 여기 밑에 있는 예제코드와 같이
포크함수를 호출한 다음에
차일드프로세스에서는 곧바로 를 호출하는 것이 일반적입니다
자 이 그림은 이렇게 가 호출되면
사용자 수준의 문맥에
어떤 일이 벌어지는가를 다시 한번 정리해 본 것입니다
먼저 R 코드를 컴파일해서
생성된 수행파일이 이름을 아웃이라고
부르기로 했었죠 자
사용자가 를 통해서 이렇게 점아웃을 수행을 시킵니다
그러면 그 결과 사용자 공간에는 왼편과 같은 사용자 수준
문맥이 만들어지겠죠
그러는 포크를 수행해서 자식 프로세스를 만들게 되겠죠
자 이 시점까지는 앞에 이야기한 바와 같이
텍스트는 공유가 되고 텍스트는 공유가 되고
데이터 히스테부분은 바로 카피가 되겠죠
자 그런데 그것도 잠시
여기 있는 자식 프로세스가 수행하는 코드에서
곧바로 를 호출하게 되면
이제 여기는 동그라미이
번 과 같이 이 내용 자체가 이제 완전히 프로그램으로
교체가 돼버린다 이겁니다
자 그렇게 되면 프로그램 카운터 를
바로 여기 프로그램이 시작되는 부분으로
세팅을 하게 되겠고요
그렇게 세팅을 하면
프로그램이 이 프로그램이 돌게 되는 거죠
자 그렇게 되면 이 데이터 영역도 당연히 수행을 위한 전역
변수들로 교체가 되겠고요
또 를 수행하다 보면
스펙도 프로그램을 수행하는데
필요한 스텝으로 교체가 되겠죠
자 이렇게 를 함으로써 이렇게 를 호출함으로써
애당초 처음에는 자식프로세스가 부모
프로세스에 카피본으로부터 시작했다가
이제는 완전히 다른 프로그램에 프로세스가 되어버린다
그것이 바로 의 역할입니다
즉 포크이후를 함으로써
완전히 다른 내용의 차일드프로세스가 되는 과정그것을 이야기하였습니다
이러한 를 가장 효과적으로 사용하는 것이 입니다
예를 들어
리눅스 라 할 때
터미널에 프로세스가 돌면서 프롬프트
이런 모양을 봤을 겁니다
이게 프롬프트데요 이
프롬프트가 깜빡거리고 있을 겁니다
그럼 거기에 같은 명령어를 하나 입력했다고 가정합시다
자 그러면 은 그 명령어를 수행시키기 위해서
자식프로세스를 하나 포크하고
곧바로 를 호출하게 되겠죠
그리고 그 를 호출함으로써
S 명령어를 수행하는 프로세스가 돌게 되는 겁니다
자 그런 후 은
자신이 만든 자식프로세스가 종료되기까지
ATE 하고 있겠죠
자 그렇게 웨이터하고 있다가 수행이 다 끝나고
엑싯을 하게 되면 이 트는 빠져나오게 되고요
결국엔 그렇게 풀려나와서
다음 명령을 받기 위해서
프롬프트를 다시 띄우게 되겠죠
자 그래서 다시 사용자 로부터 다음 명령어를 받기 위해서
프롬프트를 띄우고
거기서 명령어를 다른 걸 또 받으면
그 명령을 수행하기 위해서 를 하고
그 명령이 수행되기 끝나기까지 기다리고 있다가 에서
그 명령수행이 끝나고
나면 에서 풀려나와서 다른 명령을 받기 위해서
프롬프트를 띄우고 또 다음 명령을 또 받고
자 여러분의 입장에서는 여기서 바라보고 있겠지만
자 커널의 입장에서는 이만큼 이 돌고 있는 것이다
이렇게 보면 되겠습니다