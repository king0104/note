### 역순 range, 역순 슬라이싱 잘 사용하자!!!!! 

[핵심]

- '-1' 옵션은, 내림차순(작아지는 방향)을 의미한다!!!!

[역순 range]

- range(0,n)을 역순으로 사용하고 싶다면??  -> (n-1,-1,-1)이다!!!!!!!!!!!!!!!!!!!!! end값 -1으로 반드시!!!!!!!!

  - ```python
    range(n-1,-1,-1)
    ```

- 참고로 reversed(range()) 가 있는데, 이건 iterator를 리턴하기 때문에 그냥 무조건 range(n-1,-1,-1)으로 사용하자. - **iterator는 한번 사용하면 사라지기 때문(포인터라서)**

- 꼭 reversed(range()) 사용하고 싶으면, list(reversed(range())) 를 사용해 iterator로 객체를 만들어주어야 한다.

[역순 슬라이싱]

- 인덱스 5에서 끝까지 슬라이싱 하는데, 역순으로 슬라이싱하기

  - ```python
    #틀린 표현
    string[5::-1] # 인덱스 5부터, 4,3,2,1,0 순으로 슬라이싱
    
    #올바른 표현
    string[:5:-1] # 인덱스 끝부터, n-1,n-2,...,6,5 순으로 슬라이싱
    ```

  - []

---

### 길이(크기)가 같은 배열을 동시 접근할 때

#### 방법 1 : 인덱스로 접근하기

1. 하나의 배열의 길이로 인덱스를 만든다
2. haps[i], v_coors[i] 처럼, 인덱스로 각각을 접근한다

```python
def move_population(haps,v_coords):
    for i in range(len(haps)):
        for y,x in v_coords[i]:
            plain[y][x] = haps[i]//len(v_coords[i])
```



#### 방법 2 : zip으로 묶어서 하나씩 꺼내기

1. 두 개의 배열을 zip 함수로 묶는다
2. for a,b in zip()을 통해, 각 배열에서 하나씩 값을 뽑아 사용한다.

```python
# 2개의 배열을 zip 함수로 묶는다
def move_population2(haps,v_coords):
    for h,v_coord in zip(haps,v_coords):
        for y,x in v_coord:
            plain[y][x] = h//len(v_coord) 
```

- **두 방법의 시간복잡도 차이는 없으니, 그냥 쓰면 됨.**

---

### 인덱스 순환시키기

0. 정방향이던, 역방향이던지 다 가능한 방법

- [0,1,2,3] 이라는 **큐를 만들고**
  1. 오른쪽으로 가고 싶으면(**정방향**)(0다음 1을 보고싶으면) **popleft & append**
  2. 왼쪽으로 가고 싶으면(**역방향**) **pop() &** **appendleft()**
  3. (*참고 : 현재 바라보고 있는 곳은 list[0]이다.)



1. 정방향

0,1,2,3 이라는 인덱스를 순환하고 싶을 때 다음과 같이 작성하기

- 4->0
- 5->1
- 6->2 이렇게 생각해보면, 몇으로 나눠야하는지 느낌이 온다.

```python
idx = idx+1 if idx<4 else idx%4
```



2. 역방향

0,1,2,3 이라는 인덱스를 역방향으로 순환하고 싶을 때

- 파이썬 기준 정방향과 똑같이 mod연산 하면 된다

문제 : 삼성sw구현 - 백준 3190 뱀

---

### 시간순

1. 객체를 만들어 고유 시간을 저장해두는 방법
2. queue(혹은 stack)
   - **먼저 넣은 것은 먼저 나오는 속성이 있다.** 시간 순서가 자연스럽게 반영되기 때문에, 시간 순으로 정렬(또는 어떤 작업)을 해야한다고 하면 **queue를 생각하자. index가 작은 것이( [0], [1] .. ) 시간 순으로 앞서는 것이다!!**

---

### 해시배열

- 해시 배열 = **"확인용 배열"**
- **인덱스**가 몇번 나오는지 저장해두는 배열 (인덱스에 해당하는 값이 몇번 나오는지 저장하는 배열)
- 인덱스가 아주 중요한 키워드이다. 인덱스를 잃어버리는 순간, 해시 배열의 의미가 사라진다. 따라서, 해시 배열에서 값을 뽑기만 하는 것이 아니라 추가적인 작업을 한다면, **값과 인덱스를 동시에 가지고 있어야 한다!!!!**
- 해시 배열 자체가 인덱스와 값을 동시에 가지고 있다. 따라서, 해시배열을 활용할 때에도 인덱스와 값을 동시에 가지고 있어야 한다. 즉, 어떤 값에 해당하는 **인덱스를 반드시 가지고 있어야 한다!!**

---

### plain 배열 작성법 2개

1. only plain

   - plain = [list(map(int,input().split())) for _ in range(n) ]

2. **테두리 + plain**

   - 잘된 작성법

     - 테두리 만들고 싶은 경우, 미리 선언하고 -> 할당하기

     - ```python
       # plain에 둘레 만들고 싶으면, 미리 선언하기
       plain = [ [0]*(m+1) for _ in range(n+1) ]
       for i in range(1,n+1):
        plain[i] = [0] + list(map(int,input().split()))
       ```

   - 잘못된 작성법

     - for line in plain 으로 하면, 그냥 값을 뽑아내는거지 plain의 값은 바뀌지 않는다!!

     - ```python
       for line in plain[1:]:
       	line = [0] + list(map(int,input().split()))
       ```

---

#### 순차적 탐색 / 간헐적 탐색**

- 순차적 탐색 (for문으로 쭉 도는 것) 아니면, 탐색할 인덱스를 미리 지정해두기!!!!

- 예시)

  1. dy, dx
  2. **대각선 탐색**

- 코드예시)

  - 3*3 plain에서, 가로, 세로, 대각선의 값들을 비교해야 한다

  - for문 사용하면 이중for문 3개에, 상당히 복잡해질 상황

  - 순차 탐색이 아니라, 간헐적 탐색이므로, 인덱스 미리 지정해두기!!!

  - ```python
    # 1. 탐색할 인덱스 미리 지정해두기
    cases = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]]
    
    # 2. 해당 인덱스로 접근
    for case in cases:
    a,b,c = case
    if string[a] != '.' and (string[a] == string[b] == string[c]):
    	bingo.append(string[a])
    ```

    





---

### 종료조건

종료조건의 핵심

- 언제, 해당 알고리즘이 더이상 답을 찾을 수 없을 것인가...

- 백준 2003_수들의합 참고 - 투포인터 문제
  - 종료조건을 생각하는데에 애를 먹었다