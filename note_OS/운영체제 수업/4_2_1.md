4

자 그럼 이제부터는 이제까지 파악해 온 중요한 개념을 한데 엮어보도록 하겠습니다
자 이를 위해서 사용자 프로세스가 디스크 입력을 위한 리드시스템
호출을 해서 완료될 때까지의 과정을
종합적으로 살펴보겠습니다 

이 과정은 지난번에
쭉 한번 따라가본 적이 있습니다
일 번부터 구 번까지의 과정을 쭉 따라가면서
시스템 콜과 DMA
그 다음에 인터럽트, 슬립과 wake up 이런 관계들을 쭉 훑어가면서
따라가본 적이 있는데요 

고 그림에서는 상태에 천이라는 것은
배우지 않은 상태이기 때문에
그 상태에 상태의 천이는 설명이 포함되지 않았었습니다

자 이번에는 같은 시나리오를 갖고
문맥교환과 상태천이 pcb 이런 것들이
어떻게 엮이는 것 까지를 포함해서
한번 보고자 하는 겁니다

즉 시스템 호출 처리 
대기에 들어가면 어떻게 문맥교환이 언제 일어나고 어떻게 일어나고 
또 인터럽트가 어느 시점에 들어오고
상태 천이에 어떻게 영향을 주고 이에 따라서 pcb가 어떻게 이동되는지
그런 내용을 보고자 하는 것입니다

---

5

자 여기 예제프로그램이 하나 있는데요
우선 이 프로그램이 사용자 모두에서 실행되고 있는 상태다 이렇게 봅시다
그리고 수행 중에 my파일 이라는 파일을 오픈을 한 후
그 파일에서 100바이트를 읽어오기 위해서 buf[100]를 잡은 다음에
그 다음에 read라는 시스템 콜를 호출했다
바로 이 시점이라고 가정합시다

그렇게 되면 방금 전에도 이야기했듯이
지난번에 한번 쭉 따라가봤던
그 내용을 다시 한번 따라가는 것이 시작되는 거다
이렇게 보면 되겠습니다

자 이제까지 사용자 모드로 실행중이던 프로세스가 이
바로  read라는 시스템 콜를 하게 됨에
따라서 트랩을 통해서 커널로 진입해서
커널모드로 실행이 되게 되겠죠

---

6

![image-20220330141312426](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330141312426.png)

자 그 다음에 아마 이 그림을 기억하실 겁니다
리드라는 시스템 호출은 커널안으로 들어와서
결국엔 IDT를 통해서 시스템 콜테이블을 통해서
결국에는 read의 실제 구현함수 인 sys_read() 까지 도달하겠죠

아마 이만큼 부분 이 밑에 부분은 디바이스 드라이버 내에 있다고 봐야 되겠죠
자 그럼 자세한 이야기는 여기서부터 시작됩니다

---

7

![image-20220330141754454](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330141754454.png)

일단 슬라이드에 있는 동그라미 번호들 이런 것들은 지난번에 일본 부터 구권까지
따라가면서 보았던 번호 들과는 다른 것입니다 이 예제를 위해서
별도로 붙인 번호 들이고요
이후 상태천이도를 연계해서 설명할 때에
편의를 위해서 붙여놓은 것임을 감안해주기 바랍니다

아울러 지금부터 설명하는 유사코드는
개념적인 설명을 위한 용도로 예제를 들은 것이기 때문에
리눅스 같은 공개 소프트웨어 운영체제 완성된 코드와는 차이가 있음도
감안하여 주시기 바랍니다

개념 설명을 위한 유사코드 다 이렇게 보시길 바랍니다

자 sys_read()함수가 불렸다 그랬죠
자 sys_read()의 함수의 첫번째 임무는 응용 프로그램이 읽어오기
원하는 그 백바이트가
디스크에 어느 블록에 있는지를 알아내는 것일 겁니다

이 과정에서
**하드디스크입출력을 위한 캐시라고 볼 수 있는 버퍼캐시**
이 **버퍼캐시**에 그 찾는 내용이 들어 있는지를 먼저 봅니다
캐시이라는 것이 그런 용도니까요

그래서 하드디스크를 위해서도 버퍼캐시라는 것이 따로 있다
그래서 만약 버퍼캐시에 들어 있으면 하드디스크 입력이 이제 필요 없죠
사실 그 내용을 그냥 가져오면 되는 것이니까 

있을 경우 그 내용을 **사용자 영역인 buf으로 복사**를 하고
바로 **리턴**을 하면 되겠죠(사용자 모드로 복귀)

아주 운이 좋은 케이스죠

![image-20220330141803369](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330141803369.png)

자 만약 그렇지 않다면 디스크 입출력 요청을 위한 자료 구조라 할 수 있는 
디스크 IO 리퀘스트 블록
이거는 디스크 입출력을 위해서 사용하는
그들만의 자료 구조가 있습니다

**디스크 IO 리퀘스트 블록 그거를 하나 생성**을 합니다
디스크 블록을 하나 생성하고
그것을 **디스크 io 큐**에 입력을 하게 됩니다

---

8

![image-20220330142350485](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330142350485.png)

그렇게 되면 디스크 IO요청 블록이 이제
큐에 들어갔다가 큐에서 하나하나씩 처리되고 나면
그 **요청 블록**이 결국에는 **첫번째가 되는 순간**이 오겠죠

자 그렇게 되면은 결국은 장치 제이기라 할 수 있는 
**디스크 제어기에 명령을 하달**을 하는거죠
무슨 명령 이냐 
**해당 블록을 입력해 달라** 하는 것을 하달하게 됩니다
하드웨어 쪽으로 명령이 내려간거죠

자 이제 그렇게 되면 이 시점부터는 
현 프로세스는 디스크 입력이 완료될 때까지
어떻게 될까요 cpu를 반납하고 대기상태로 진입해야 되겠죠

입력이 끝날 때까지는
굳이 를 붙잡고 있을 이유가 없으니까요

![image-20220330142407200](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330142407200.png)

자 이를 위해서 sleep_on 이라는 커널 내의 함수를 호출하게 됩니다
자 sleep_on함수의 내부 흐름은 다음 슬라에서 에서 보도록 하겠구요
아무튼 s**leep_on 호출하면**
**그 안에서 결국에는 이 프로세스는 대기상태로 진입**된다는 거죠
그러니까 결국에는 슬립온에서 대기 상태로 진입되니까
**여기서 멈춰 있는 겁니다**

멈춰있고 그 멈춰 있는 동안에는
**IO가 일어나게 되겠고**
**즉 디스크 입력**이 일어나게 되겠고
그 사이에 는 다른 걸 돌리고 있겠죠

![image-20220330142525646](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330142525646.png)

자 그런 작업들이 다 끝나고 난 다음에
다시 깨어나보면 그 다음 줄이 되겠죠
sleep_on의 다음 주
바로 이 줄를 수행하게 되는 순간으로 다 깨어나게 되는 겁니다
그게 wake up 이죠

**wake up 이 됐다는 거는 대기 상태가 끝났다는 거고**
**대기 상태가 끝났다는 것은**
**디스크 입력이 끝났다는 거죠**

그러니까 결국에는 이제 할 일이 뭡니까
디스크 입출력 을 위한 버퍼인 버퍼캐시로
당초 리드해 오고자 했던 데이터가 읽어들어와 있을 테니까

이 버퍼캐시에서 사용자 영역으로 자료를 복사하게 되는 거죠 
이 **사용자 영역이라는 것**이 아까
응용 프로그램이 있던 **buf라는 그 영역**이 되겠죠

자 그런 후에 이 사용자 모드 로 복귀하면서
sys_read함수를 빠져나가게 되겠죠

리턴을 하게 된다는 겁니다

그렇게 되면 아까 응용 프로그램에서 호출했던 read 라는 시스템 콜함수
그 다음 줄로 이제 다시 또 리턴이 되어 가겠죠

---

9

![image-20220330142718187](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330142718187.png)

자 그럼 sleep_on() 내부의 함수가
매우 궁금할 것 같은데요
내부 흐름을 한번 보도록 하겠습니다

슬립온 함수는 먼저 프로세스 스스로를 대기상태로 처리하기 위해서
pcb상의 상태정보를 running상태에서 blocked 상태로 변경을 합니다

그런 후 이제까지 실행상태에 있는 동안에
준비리스트 에 머물던 pcb를 해당 이벤트에 해당하는 대기큐로 옮기게 됩니다

(= 준비리스트에서 삭제해서 종류별 대기 큐로 옮긴다)\



참고로 **프로세스가 실행상태**에 있더라도
**pcb는 준비리스트 에 보관될 수밖에 없고**
**단지 상태표시만 러닝상태로 바뀌어 유지된다는 것**
전 페이지에서 설명한 바 있는데요
그것을 잘 상기하길 바랍니다

![image-20220330143122480](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330143122480.png)

자 이렇게 되면 다음 할 작업은 **스케쥴링**을 통해서
다음 실행할 프로세스 를 선정하는 작업이 될 것입니다
이를 위해서 **준비리스트에서**
**우선순위가 가장 높은 pcb를 선정**하게 되겠죠

자 이렇게 다음 실행할 프로세스가 선정되면 
결국 **문맥교환함수**인 **컨텍스트스위치 라는 함수를 호출**하게 되는데요 
이 컨텍스트스위치 함수를 호출해서 
현 프로세스의 문맥을 해당 pcb에 보존을 하고
새 프로세스의 pcb에 저장되어 있는 문맥을 reload 하게 됩니다

자 그렇게 되면 새로운 프로세스의 pcb가
지난번에 이야기했던 프로그램 카운터 정보를 담고 있기 때문에
바로 그것이 cpu에 로드 되는 순간
그 프로세스로 점프를 하게 되는 것입니다

![image-20220330143211971](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330143211971.png)

다시 말해서 이제까지 쭉 이렇게 수행되어오던 현
프로세스의 pcb에 문맥을 세이브를 하고
새로 선정된 프로세스의 pcb에 있는 문맥을 restore을 하는거죠

cpu에다가 restore를 하면
바로 그 다음부터 새로운 프로세스가 속개되게 되는거죠

![image-20220330143045679](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330143045679.png)

자 그동안에 현재까지 실행되던 이 flow는 여기서 정지를 하는 겁니다
즉 대기를 하는 거죠



![image-20220330143412239](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330143412239.png)

자 그랬다가 입출력이 다 끝나고 나서
인터럽트 도 들어오고 해서 다시 또 스케쥴링 이 한번 일어나서
결국에는 이 프로세스가 선정이 돼서
수행이 속개되는 순간이 또 오겠죠

그러면 바로 여기로 
빨간 화살표 이 지점으로 리턴이 된다
또는 이지점부터 속개된다

이렇게 보면 되는 겁니다

그러니까 결국에는 이 지점으로 복귀되었다는 것은 

이미 대기큐를 빠져 나와서
준비 상태를 거쳐 
스케쥴링 이 일어난 결과로서
이렇게 다시 실행상태로 오게 됐다 이거죠

그래서 아까 blocked상태로 바뀐 것이
여기서는 러닝상태로 바뀌어 있을 겁니다

자 결국에는 이게 wakeup 과정을 거쳤다는 거죠
**wake up과정을 거쳐서 상태는 러닝으로 바뀌고**
**바로 이 시점부터 속개가 되게 됐다** 바로 그거죠

---

11

자 방금 전에 이야기했던 웨이컵이라는 것은 
알고 보면 인터럽트 처리함수인 ISR로부터 시작되게 되는 것인데요
해당  ISR 의 내부 흐름을 한번 보도록 합시다

본 예에서 ISR 함수 의 이름은 **디스크 인터럽트 핸들러(= int disk_intr_handler(,,,) )** 입니다 

이 함수 는 디바이스 드라이버 내에 존재하겠지만
역시 부팅시에 IDT에 등록이 되어 있었기 때문에 이 함수로
점프해 들어올 수 있었던 것이겠죠

자 이 isr함수로 들어오면
이러한 디스크 입력이라는 복잡한 여정의 시작이 되었던 요청 블록이 있었죠
그것이 **디스크 io 리케스트 블록**인데
그것이 어디 들어있냐면 현재 **디스크 io 큐의 프론트**에 있었겠죠
그것을 이제는 그 작업이 끝났으니까
**제거**를 하는 겁니다

자 그 다음에 결국에는 아까 그 sleep on 하게 되었던 프로세스

우리의 관심 프로세스죠
그 입출력을 요구한 그 프로세스의 현재 pcb가 어디에 들어가있냐하면
대기KYU에 들어가 있다고 그랬죠
**그 대기KYU에서 그 pcb를 꺼내서 준비**
**리스트로 옮기게 됩니다**
자 이렇게 준비리스트에 옮기게 되는 것은
바로 곧 다시 이 원래 입출력을 요구했던 우리의 관심
프로세스를 수행시키기 위한
준비 과정이라고 보면 되겠죠

그래서 **대기큐에서 제거해서**
**준비리스트로 옮긴다는 것은 사건이 끝났으니까**
**그 사건을 기다리고 있던 프로세스를 깨운다**는 거겠죠

그래서 그러한 과정을 **wakeup프로세스**라고 부릅니다
이렇게 현 지금
이렇게 비를 대기 KYU해서 제거해서 준비리스트로 올리고
나중에 보면 알겠지만
이제 곧 스케줄러도 동작을 하겠죠
자 그런 과정이 wake up프로세스다 부르는 겁니다



자 그런데 이제 wakeup 프로세스의 이제 마지막 단인데요
그렇게 해서 wakeup을 해놓고 그냥 빠져나가면 안 되고
여기서 디스크 상의 아까 디스크 요청 블록 제거했다고 했지 않습니까
제거하고 나면 **그 다음 디스크 요청 불락**이 있을 겁니다
차순위로 있던 거예요

그것을 일단은 꺼내서 내용을 보고
**거기에 해당하는 입출력을 시작**시킨 후
바로 **이 인터럽트 핸들러 에서**
**복귀하는 절차**를 밟아야 되겠죠 



이 복귀하는 절차에서 아까
준비리스트에 삽입이 됐으니까
그 준비리스트가 변화가 있었죠
그렇게 준비리스트가 변화가 있으면
스케줄러를 한번 동작 시켜줘야 되겠죠

그런 과정에서 바로 **준비리스트에 들어간 우리의 관심**
**프로세스가 우선순위가 높다면 실행**이 되겠죠
그런데 당장 실행이 되지 않을 수도 있습니다

더 높은 우선순위가 있을 수도 있으니까요
자 어쨌거나 **이렇게 준비리스트 에 들어가게 되면**
**당장 이 아니더라도 언젠가는 스케쥴링 에 의해서 선택이 돼서**
**다시 실행상태에 들어가게 돼 있다**

그 실행 상태에 들어갈 때
**또 한번의 문맥교환**을 해서
그 프로세스가 속개가 되겠다
바로 그런 거죠 

---

12

이상에서 설명한 내용을 잘 따라오셨나 모르겠습니다
혹시나 해서 이해를 돕기 위해
상태천이라는 측면에서
다시 한번 따라가보도록 하겠습니다

여기 그림에 보면 동그라미번호 들이 있는데요
이런 것들이요 이 번호 들은 이전
슬라이드에 표시된 번호 들과 일치합니다

그래서 전 페이지에 내용들을 보면서 비교하면서
따라가보면 좋겠습니다 그림이 복잡하니까 단계적으로 따라가봅시다

---

13

![image-20220330145459378](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330145459378.png)

현재 프로세스
즉 응용프로그램에서부터 시작된
그 프로세스를 A이라고 부르도록 합시다
현재 프로세스 가 실행상태이므로
분명 **1. PCB의 상태는 러닝상태**가 있고
그것은 **2. 준비 큐의  맨 앞부분**에 있을 겁니다
**이유 : 우선순위가 가장 높았기 때문에 현재 실행상태가 되었을 테니까**요

자 준비리스트 이기도 하겠지만
본 설명에서는 편의를 위해서 준비 큐라 하겠습니다 **(준비리스트 = 준비큐)**

자 그리고 현재 경쟁 프로세스가 비가 있다고 합시다
설명을 단순하기 위해서
현재 시스템이 이렇게
두 개의 프로세스만 있다고 가정을 합시다

자 그러면 1 번
사용자 모드로 동작하던 프로세스가 리드 시스템 콜를 합니다

자 그러면 커널모드로 들어와서
시스리드라는 디바이스 드라이버 내의 함수까지 들어오겠죠

자 2 번 하드 디스크 제어기에 하드 디스크로부터의 백바이트
데이터 입력명령을 하달을 하겠죠

---

14

![image-20220330145743507](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330145743507.png)

그런 후 sleep on 함수 내에서 보았듯이
3 번

프로세스상태가 이제까지 러닝상태였었죠
러닝상태에서 블록트상태로 변경되고

준비KYU에 있던 pcb가 대기KYU로 이동이 됩니다
즉 **1. 러닝상태에서 블록**으로 바뀌고
**2. 준비 큐의 맨 앞부분A 가 있었는데**
**그것이 대기KYU로 옮기게 된다** 이겁니다



자 물론 pcb가 이동된다기보다는
당연히 pcb 포인트가 이렇게 이동이 되게 되는 거겠죠

자 그렇게 되면 실행상태에 있는 프로세스가 이제 없죠
여기가 비어 있지 않습니까 지금? **( 준비 큐의 맨 앞부분 보기)**

자 그렇기 때문에
준비 큐를 대상으로 **스케쥴링**을 한번 하겠죠
현재는 프로세스비만있으므로 당연히 비가 선정되겠죠



자 그래서 4 번
그런 비의 상태를 러닝상태 
큐에서 기다리던 **1. 레디 상태에서 러닝상태**로 바뀌고
**= 프로세스비가 이제 수행**되게 되는 겁니다
그렇게 수행되게 될 때 컨텍스트스위치가 일어나겠죠

즉 문맥교환이 일어나게 돼서
그때 이제 프로세스 A 가 중단이 되고
프로세스 B가 속개가 되는 일이 요 4번에서 일어나겠죠

---

15

자 그러면 한편으로 아까 명령을 내린 디스크 입력명령은 현재 어떻게 되고 있을까요

좀 시간이 지나면 이제 디스크 제어기는 DMA를
통해서 디스크 입력작업을 마치고 **1. 인터럽트** 를 걸어오게 될 것입니다
그러면 **2. CPU는 프로세스B 를 잠시 멈추고**
**3. ISR인 디스크 인트로트핸들러를 수행**하기 시작할 것이고

![image-20220330150114586](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330150114586.png)

여기서 5번
즉 프로세스 A 상태를 **1. 블록상태에서 READY상태**로 바꾼 다음에
**2. 대기 큐에서 꺼내서 준비 큐로 이렇게 이동**을 하겠죠

현재는 비가 돌고 있던 상황이었기 때문에
**준비 큐에 비보다 뒷부분**으로 들어가게 되겠죠 (그림 참조)



다시 말해서 하드 **디스크 제어기가 100 바이트 의 데이터를** 
**DMA를 통해서 메인 메모리로 옮긴 다음에** 
**인트럽트** 를 걸면 인트럽트 핸들러로 들어가게 되는 거고요



**인트러브핸들러** 에서는 아까 유사코드에서 설명했듯이
이제까지 블록돼 있던 **대기KYU에서 기다리던 A이라는 프로세스를**
**그 상태를 READY 상태로 바꾸고 준비 큐로 옮기는데**
**준비 큐에 뒤쪽으로 들어가게 되어 있다** 이 것입니다

---

16

사실 이야기를 잠깐 생략했었는데요
여기서 짚고 넘어갈 것이 하나 있습니다
현재 처리하고 있는 이 인트럽트가 발생해서
인 트로트가 들어왔을 때 이야기입니다 

![image-20220330150520957](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330150520957.png)

이 들어왔을 때 그 당시에는 프로세스 B가 실행되고 있었겠죠
근데 그 비가 실행을 잠시 멈추고
현재는 러닝에서 READY상태로 변경되어 있을 겁니다
왜냐하면은 이 인트로프트를 처리했었어야만 했기 때문이죠



자 그래서 인트럽트 처리가 되고 있는 동안에는
B라는 프로세스는 실행상태가 아니라
러닝상태에서 레디 상태로 변경되어 있을 것이다

따라서 대기KYU에서 옮겨간 A와 
비자발적 문맥교환에 의해서 실행상태로부터 쫓겨나서
인터럽트 때문에 쫓겨나서 준비 큐에 그냥 준비상태로 머물고 있는
이 두 개가 다시 스케쥴링 의 경쟁대상이 되는 거죠

자 그래서 인터럽트 가 끝나고 나면 
A 와 B 가 스케쥴링에 의해서 경쟁이 일어나게 될 것입니다

자 여기서는 이 경쟁에서 A 가 이겼다고 봅시다
그렇게 되면 바로 A 가 속개 되게 되겠죠
즉 스케쥴링 에서 A 가
선정되면 다시  READY상태에서
러닝상태로 가게 되는 거고 이 러닝상태가 되면은
결국에는 read()라는 시스템 콜의 리턴과정을 속개하게 되는 것이죠

---

17

![image-20220330151122044](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330151122044.png)

다시 한번 전체적으로 정리를 해보도록 합시다
사용자 모드로 돌고 있던 프로세스 A가 수행 중인 상태에서
read() 시스템 호출을 하면
결국에는 커널모드로 들어와서 시스리드라는 디바이스 드라이버
내 함수에 의해서 하디스크를 구동시킨다
**하드 디스크 제어기의 요청**을 함으로써요 

---

18

3번

그렇게 되고나면은 프로세스 A에 있는 더 이상 수행을 할 수가 없기 때문에
결국에는 대기 상태로 들어가야 되는데

대기 상태로 들어가기 위해서는

1. 프로세스의 상태를 러닝상태에서 블록상태로 놓고
2. 준비KYU에 있던 것을 대기KYU로 옮기게 된다

그렇게 되면 A 는 실행을 더 이상 할 수가 없기 때문에
다른 프로세스 하나를 선정해야 되는데

4번

---

![image-20220330151329392](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330151329392.png)

자 그렇게 하기 위해서 **준비KYU에서 스케쥴링**을 하게 되고
현재는 비밖에 없으니까
비가 선정돼서 실행이 되게 된다
그것이 바로 여기4번
**프로세스비가 실행상태가 되는데**
**즉 레디에서 러닝으로 바뀐다** 이거죠

자 그러다 보면은 하드디스크 제어기에서 디스크 입력을 끝내고
인터럽트를 걸어오게 되는거죠

자 인 트럭 틀을 걸어오게 되면
대기KYU에 있던 A이라는 프로세스를 준비KYU로 옮기게 되면서
블록드상태를 READY상태로 바꿔주게 된다

---

20

![image-20220330151444679](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330151444679.png)

자 그런데 이렇게 인트로프트가 들어왔을 때
어떤 일이 일어 났었냐
하면은 자 그때 실행이 비가 되고 있었는데

![image-20220330151500109](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330151500109.png)

비도 인 트로트처리를 위해서 **비자발적으로 문맥교환이 돼서**
**다시 준비KYU로 들어와 있게 된다**
즉 **러닝상태에서 레이디상태로 바뀐상태**가 되게 된다

그래서 그렇게 놓고 보면 인터럽트 가 들어오고 난 다음에는

 A와B 두 개가 준비에 들어 있게 되는 거고

![image-20220330151523328](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330151523328.png)

여기서 준비에 있는 사이에 스케쥴링 이 일어나게 돼서 
A가 선정되었다면 A가  READY상태에서 러닝상태로 상태가 변화되게 되는거죠



자 그렇게 되면 아까
여기서 하드디스크로 입력 명령을 내리고
대기 상태로 들어가게 된
그 시점 이후의 코드로 속개가 되게 되겠죠

그 속개되는 그 내용이
결국에는 리드 시스템
콜의 리턴과정을 수행하게 되는 겁니다

![image-20220330150944903](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20220330150944903.png)

자 그렇게 되고 나면은
응용 프로그램의 메인 프로그램이 있었을 거고
리드가 있었겠죠
죽실행돼서 현재 이 리드라인 하나
때문에 이 많은 일이 벌어진 거니까요

**리턴과정을 수행하게 된다는 것은 다음 줄**로,
**응용프로그램입장에서는 read 다음 줄로 복귀가 되는 것**이다



그러니까 알고 보면
**리드 시스템 호출 하나가 이 많은 커널내에 일들을 야기시키는 거**고
그 과정들을 지금 한번 개괄적으로 본 것이다
이렇게 보면 되겠습니다