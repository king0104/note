## 정렬

#### Intro

*데이터를 특정한 기준에 따라 순서대로 나열하는 것.*

정렬 알고리즘으로 데이터 정렬 -> **이진 탐색** 가능

(정렬 알고리즘은 이진탐색의 전처리 과정)



### 1. 선택정렬

#### 수도코드(원리)

for ( int i = 0; i < N-1; i++ )  *즉, N -1 번 반복*

1. 가장 작은 데이터를 선택
2. 맨 앞의 데이터와 바꾸기

### 

#### 그림

![image-20210721104025796](C:\Users\4545a\AppData\Roaming\Typora\typora-user-images\image-20210721104025796.png)

#### 시간복잡도

- 가장 작은 데이터를 선택 -> N, N-1, N-2, ... 2 해서 맨 앞으로 보내기

- (N^2+N) / 2

- O(N^2)
  - 직관적으로 2중 반복문 사용해서 그렇구나~
  - 읽어들이는 데이터의 갯수



### 2. 삽입정렬

#### 특징

- 특정한 데이터가 적절한 위치에 들어가기 이전에, **그 앞까지의 데이터는 이미 정렬**되어있다고 가정한다

- 필요할 때만 위치를 바꾸므로, **데이터가 거의 정렬**되어 있을 때, **훨씬 효율적**

#### 수도코드(원리)

- for( int i = 1 ; i < N ; i++) 

  - N-1번 반복
  - 두번째부터 마지막 카드까지

  1. 카드 하나 뽑기
  2. 앞부분에 오름차순 규칙 맞춰서 삽입하기



#### 시간 복잡도

- O(N^2)
  - 직관적으로 2중 반복문 사용해서 그렇구나~



### 3. 퀵 정렬

- 피벗 사용
- 재귀 함수와 비슷하다
  - 종료 조건 : 현재 리스트의 데이터 개수가 1개인 경우
- 시간복잡도
  - 평균 : O(NlogN)
    - 분할이 이루어지기 때문에, log 스케일로 줄어든다.
    - 8,4,2,1 로 줄어드는데, 이 높이가 약 logN 정도.
  - 최악 : O(N^2)
- 이미 데이터가 정렬되어있는 경우, 매우 느리게 동작한다.

### 4. 계수 정렬(count sort)

- **해시 배열**을 이용하는 것.
  - '모든 범위를 담을 수 있는 크기의 배열을 선언(=해시 배열)' 해야 한다.
  - 그래서, 데이터의 크기 범위가 제한되어 정수 형태로 표현 가능해야함.
  - 가장 큰 데이터 - 가장 작은 데이터 = 1,000,000 넘지 않을때만.

- 시간 복잡도
  - O(N+K)
- 공간 복잡도
  - O(N+K)

- **데이터 크기가 한정, 데이터가 많이 중복**되어 있는 경우
  - ex) 학생 성적, 알파벳 정렬하기 등





