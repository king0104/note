### 개념 : DFS or BFS

- 문제에 적용할 때, 아무거나 적용해도 되는 경우가 대부분. 어떻게 하던지 탐색을 하는 경우라면, 둘 다 사용할 수 있다. 여기서, 조금 나누자면 다음과 같다.

#### dfs

- 어떻게 하던지 간에 탐색을 하면 되는 경우

- 팁)
  - pypy3로 메모리 초과난다 -> sys.setrecursionlimit(10**5) 로 바꾸기

#### bfs

- **탐색에 순서가 있는 경우**. 한 칸 다음 다음 3칸 탐색 이런식으로 순서가 정해지면, bfs를 사용해야한다.
- 그래서, 좌표평면에서 자주 쓰인다. 
  - **그렇지만, 좌표평면을 탐색하는 문제는 사실 순서가 중요한 것이 아니라 "그룹짓는 것"이 중요해서 어떻게 하던지 탐색을 하면 되는 경우에 속한다. 그래서, dfs로도 충분히 풀린다.**



---



#### 문제 풀이 : 그래프 탐색 vs 좌표 탐색

#### 그래프 탐색

- 정의

  - 고전적인 그래프를 탐색하는 것.

  - 즉, node / edge로 이루어져있음

- 문제 푸는 방식

  - edge가 입력으로 주어진다. 
  - **이것을 받아서, 그래프를 만든다**
  - 그래프를 탐색한다
  - 새로운 class를 정의하는 경우도 있다.

  

 #### 좌표 탐색

- 정의

  - 문제가 좌표평면에서 이루어짐
  - 즉, (y,x)로 이루어짐

- 문제 푸는 방식

  - (dfs, bfs 상관없음) 

  - **방향배열 설정**

  - 모든 방향에 대해 갈 수 있는 지 여부 확인(여기서, if 문에 들어가는 좌표는 ny, nx임을 명심. 이거 y,x로 잘못써서 엄청 틀렸다. 특히 visit[ny] [nx] 를 계속 잘못씀...)

    ```python
    for i in range(4):
            ny = y + dy[i]
            nx = x + dx[i]
                
            if (0<=ny<n) and (0<=nx<n) and not visit[ny][nx] and check_open(plain[y][x], plain[ny][nx]):
                flag = 1
                hap += dfs(ny,nx)
    ```

- **꿀팁 - 진짜 이거 개 꿀팁.... <재귀에서 리턴값으로 누적값 모으기>**

  - 만약 dfs로 좌표평면 문제를 풀 때, 한번의 dfs 탐색에서 얻어야 하는 누적값(예 - 탐색 구간의 누적합)이 필요하면 리턴 값을 활용하자!!!!!!!!!

    1. dfs 함수 내에 hap = 0 과 같은 누적값 저장 변수 선언하기

       1-1. dfs 함수 내에서, 현재 상태의 값을 변수에 할당하기

       1-2. dfs 함수 내에 dfs 함수 호출 할 때 리턴 값으로 받아오기

    2. dfs의 리턴 값으로 해당 변수 주기

    3. 실제로 dfs 함수 호출하는 부분에서 리턴값으로 받는 값이, 우리가 원하는 값임!!!!

  - 예시 코드

    - ```python
      def dfs(y,x):
          
          global flag
          # 1. 변수 선언
          hap = 0
          
          # (1. 방문한 좌표)
          if visit[y][x]:
              return
          
          # (2. 방문하지 않은 좌표)
          visit[y][x] = True
          # 1-1. 현재 상태를 변수에 할당하기
          hap += plain[y][x]
          
          y_list.append(y)
          x_list.append(x)
          
          
          for i in range(4):
              ny = y + dy[i]
              nx = x + dx[i]
                  
              if (0<=ny<n) and (0<=nx<n) and not visit[ny][nx] and check_open(plain[y][x], plain[ny][nx]):
                  flag = 1
                  # 1-2. 리턴값으로 받아오기
                  hap += dfs(ny,nx)
          
          # 2. 리턴값으로 변수 지정
          return hap
      ```

      



