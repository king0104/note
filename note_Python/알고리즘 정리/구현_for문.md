#### <"순차적으로 탐색하고 싶을 때" 사용한다!!>

#### for문의 목적

1. 동작 반복
2. **순차적으로 증가하는 인덱스 사용** + 동작 반복

- for문은, 위의 2가지를 목표로 사용되는 것이다. 그래서 **특정한 동작**이 무엇인지, **인덱스가 의미하는 바**가 무엇인지 아는 것이 매우 중요하다.

- "for문 사용할 때 항상 생각할 것" 에서 살펴보도록 하자.





#### for문 사용할 때 항상 생각할 것

1. 항상, **for문의 목적**을 정확히 알아야 한다!!!

- 반복문은, **특정한 동작**을 여러번 수행하는 것이다. 이 특정한 동작이 무엇인지, 정확하게 알아야 한다.

- 그래야 추가적인 작업을 하기 수월함

- ```python
  # <예시>
  # for문 사용 시 '목적을 정확히!'
  # 공유기를 설치할 집을 선택하기 위해, for문으로 house를 도는 것이다.
  for home in house:
      if home >= cur + mid:
          cur = home # 다음 위치로 갱신
          cnt += 1 # 공유기 1대 설치
  ```

- ```python
  # <예시>
  def fill(temp, dirs, y, x):
      for dir in dirs:
          ny = y
          nx = x
          while True:
              ny += dy[dir]
              nx += dx[dir]
              if not(0<=ny<n and 0<=nx<m) or temp[ny][nx] == 6:
                  break
              temp[ny][nx] = 7
  ```
  
  



2. for i in range(start,end,step) 에서, **i가 가지는 의미**가 무엇인지 정확하게 알아야 한다!!!!

#### 가장 중요한 것은, **" i = 순차적인 인덱스!!!!!!!!!"** 라는 것이다.

- i의 후보군

1. **배열의 순차적인 인덱스**

   - 배열을 순차적으로 접근하고 싶을 때, for문의 i를 사용한다.

     - 1부터 n까지 탐색하는 경우 (쉬움. 일반적인 경우)

     - step을 주면, 1,3,5,7 이렇게 탐색할 수도 있음

     - ```python
       for i in range(1,3):
         arr[i]
       ```

   - 특히, **해시 배열**에서 자주 사용되는데, **해시 배열은, 인덱스를 사용해서 접근하는 매우 대표적인 배열**이기 때문이다.

   - 해시 배열을 순차적으로 접근하고 싶은 경우에는, 당연히 순차적인 인덱스 값이 필요하게 된다. 이때 for문의 인덱스 i를 활용하게 된다.

     - ```python
       dy = [-1,0,1,0]
       dx = [0,1,0,-1]
       
       for i in range(4):
       	ny = y + dy[i]
       	nx = x + dx[i]
       ```

       




  2. **특정 인덱스 기준, 인덱스의 증가(감소)량 i**
- **특정 인덱스를 시작점으로, 배열의 순차적인 인덱스 k+i**
     - 이 경우에는, i의 의미를 생각하기보단, k+i의 의미를 생각하는 것이 훨씬 이해하기 편하다. 배열의 인덱스 자체가 어떤 것을 의미하는지 생각하는 것이 편하다는 뜻이다.
- 특정 인덱스에서, 특정 길이만큼만 탐색하고 싶은 경우 - 즉, k라는 특정 인덱스에서, 2개의 인덱스만 탐색하고 싶은 경우 (조금 복잡할 수도, 하지만 아래의 코드 생각 몇 번 해보면 아주 편함)	

```python
for i in range(1,3):
  arr[k+i]
```



3. 1번과 2번을 응용한, 해시배열

```python
dy = [-1,0,1,0]
dx = [0,1,0,-1]

now_dir = 1 # 특정 인덱스를 시작점으로
for i in range(4):
	ny = y + dy[(dir + i) % 4] # 배열의 순차적인 인덱스를 의미한다
	nx = x + dx[(dir + i) % 4]
```



팁) 1번과 2번 합치기

- 1번과 2번을 합치면, 특정 인덱스를 기준으로, 인덱스를 순차적으로 증가시킬 수 있다.
- 이 말은 즉, 배열을 순차적으로 탐색할 수 있다는 것을 의미한다.





---



#### 1. for문 + 배열의 인덱스 (= for i in range() ) 

- 모든 언어에서, 배열을 탐색할 때 사용하는 가장 기본적인 방법.

- 배열을 슬라이싱 하거나, 끊어서 사용하고 싶을 때. "배열의 인덱스" 를 증가/감소 시키는 방식으로 배열 탐색하기

- 두개의 배열을 같은 인덱스로 탐색하고 싶을 때 사용.

  - ```python
    tmp = list(map(int,input().split()))
    a = tmp[0]
        
    for i in range(1,len(tmp),2): # 배열의 인덱스로 for문 돌리기
    
    	if tmp[i] == -1:
    		break
    
    	b = tmp[i]
    	c = tmp[i+1]
    
    	graph[a].append([b,c])
    ```




---



#### 2. for문에서 step 사용하기

- for문을 사용하는 이유는, **반복적인 작업**을 하기 위해서이다.
- for i in range(10) 를 사용할 땐, for문의 코드 내용이 10번 반복되도록 하기 위해서이다.



- 그런데, 10번 반복은 맞지만, for문 안에 "새로운 내용 2개를 반복"하는 것을 5번 진행해서 10번을 채우고 싶다면 어떻게 해야할까??

- **for문에서 step을 사용하자!!!**

  - ```python
    a1 = []
    for i in range(0,10000,5):
        for j in range(1,6):
            a1.append(j)
    ```

  - 10000개짜리 배열을 만들고 싶은데, 1,2,3,4,5라는 숫자를 반복시켜서 10000개를 만들고 싶은 경우이다

  

  - 첫번째 for문 : 
    - 0,10000을 탐색하되, step = 5를 준다
  - 두번째 for문 : 
    - 배열에 1,2,3,4,5 다섯개 원소를 집어넣는 작업을 한다.
    
  - 이렇게 진행하면, 5개 짜리 반복을 2000번 사용해서 10000번을 채울 수 있게 된다.



**=> 반복 작업 + 반복 작업을 할 때, step을 사용해보자.**



---



#### 3. for문 + 업데이트(기본) (-1)

- **하나의 상태에 여러번 접근할 수 있다면, for문 + 업데이트**

- dp적 사고의 핵심이기도 하다.

  - 이것을 dp적 사고라고 부르는 이유

    1. 하나의 상태 = dp[n]

    2. 하나의 상태를 업데이트 하는 식 = 점화식



- ```python
  '''
  <수도코드>
  하나의 상태를 초기화하기
  for i in range(n):
  	하나의 상태를 업데이트 하기
  '''
  ```



#### 3-1. 하나의 상태에 여러번 접근할 때, 주의점

- 초기값은 절대로 나올 수 없는 값으로 해야한다.
  - **max_ans = int(-1e9)**
    min_ans = int(1e9)
  - **그냥 멋모르고 max_ans = 0으로 했다가 계산한 max가 0보다 작은 값이 나올 수 있기 때문에 틀렸다!!!!!!!!!!!!!!!!!!!!!!!!!!**


----

#### 4. for문 + break

- for문으로 배열을 탐색하면서, 어떤 조건일 때 해당 for문의 작업이 종료되면 되는 것인지 확실하게 알아야 함.
- for문의 작업이 종료되어야 하는 그 시점(그 조건)일 때, break 반드시 사용하기



- break를 확실히 줄 수 있으려면, for문이 정확히 어떤 작업을 하는 것인지 알아야 한다.

---

#### 5. for문의 의미

- 특정한 동작을, 반복한다는 뜻이다.
- 반복문의 단위는, **"특정한 동작"** 이다!!
  - 특정한 동작을 반복하는 것을 반복문으로 묶은 것이다.
- 즉, for문 안에 있는 동작이 "어떤 동작을 수행하는 것인지"를 확실하게 알면, 이중 for문이나 for, while문의 연속도 해석하거나 작성하기 쉽다.



---

#### 6. 조건 확인용 for문 (=  for문 1번 + 예외상황 break)

- **어떤 조건을 확인할 때 자주 사용된다. 조건에 일치하지 않으면, break되는 것이다.**

```python
stop_x = -1
# for문
for j in range(4,10):
  # 예외
  if plain[y][j] == 1 or plain[y+1][j] == 1:
  	break
  # 정상
  stop_x = j
```

