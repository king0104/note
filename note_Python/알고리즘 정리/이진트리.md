## 이진트리(binary tree)

- 순서가 존재한다

- 외울 것

  - node **n개**면, edge **n-1개**
  - height **h**이면, node **h ~ 2^h-1개**
    - 등비수열의 합 생각하면 된다. 1,2,4, ... 이것들의 합이 node수임

  

#### 순회(탐색)하기

- **서브트리를 단위**로 생각

- 시작점만 다르고, 왼쪽에서 오른쪽으로 간다고 생각

- 아래의 구분은, 루트노드(아래에서는 1번노드)를 탐색하는 순서가 첫번째인지, 중간인지, 마지막인지에 따라 구별짓는 것이다.

  - ```
      1
    2   3  으로 되어있는 트리를 생각하자.
    ```

  - 전위(preorder)

    - 1,2,3 순

  - 중위(inorder)

    - 2,1,3 순

  - 후위(postorder)

    - 2,3,1 순

----

### heap

- 외우기

    - 인덱스 0은 비워둠. 1부터 시작

    - 부모, 자식 노드 인덱스(아래 그림)
    
        - ```
          	(i)        : 부모노드
          (2i)   (2i+1)  : 자식노드(왼,오) 
      ```

#### 삽입(push)

1. 맨 끝에 넣어주고
2. 루트 도달하기 전까지, 스위칭 필요하면 -> 스위칭

#### 삭제(pop)

- 루트 노드를 삭제하는 것이다.
1. 마지막 노드를, 1번 노드에 넣기
2. 왼쪽 child, 오른쪽 child 중 어느 쪽과 비교할 지 고르기
3. parent vs child 비교 후, 스위칭 or 멈추기



#### 삽입/삭제 시간복잡도

- O(h) = O(logN)

- ```
    1
    2   3
  4 5 6 7
  
  O(h): 위의 트리에서 h만큼 올라가거나, 내려가기 때문.
  O(logN): 생각해보면 됨.
  ```

  
