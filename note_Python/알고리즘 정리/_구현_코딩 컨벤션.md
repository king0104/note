### for문 사용법 (= for문 + 업데이트) (-1)

- **for문 바로 위에 초기값 한번만 설정하기**

- **for문에서 (특정 조건 만족 시) 업데이트 하기**

  - ```python
    ans = 0 # 1. for문 바로 위에 초기값 한번만 설정하기
    
    for i in range(5)
    
    	if i > ans: # 2. for문에서 (특정 조건 만족 시) 업데이트하기
    		ans = i
    	
    print(ans)
    ```




### 조건문 사용하기

- 조건문에서의 "비교" : **같은 것**을 비교하는 것. 더해지거나 곱해진다고 헷갈리지 말자

  - 예를 들어, 거리라던지, 위치라던지 하는 것. 

  - ```python
    # 아래의 코드는, "거리" 라는 같은 값을 비교하는 중이다.
    if home >= cur + mid:
    ```

    

- 조건으로 return 할 줄 알기

  - ```python
    return cnt >= c
    # if cnt >= c:
    #     return True
    # else:
    #     return False
    ```





### 변수 사용하기

- **새로운 변수가 기존 변수와 겹치지 않도록 주의**!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! - 특히, 기존 코드를 고쳐보거나 수정해볼때, 이전 변수명들이 기억 안나서 겹치는 변수를 만들 수 있으니, 항상 주의하자. 이걸로 두시간은 잡아먹음...



- **중복되는 코드(변수) 하나로 합치기**

  - 아래 코드는, x에 대한 코드가 2번 사용된다. 그 두개를 합쳐서 중간 x에 그냥 넣어버리면, 굳이 x를 사용하기 위해 여러번 초기화하지 않아도 된다.

  - ```python
    # 더러운 코드
    cur = home_list[0]
    x = cur + mid
        
    cnt = 1
    for home in home_list:
        if home >= x:
            cur = home # 다음 위치로 갱신
            cnt += 1 # 공유기 1대 설치
            x = cur + mid
    ```

  - ```python
    # 깔끔한 코드(x 하나로 합침)
    cur = -1e9
    cnt = 0
    	for home in home_list:
    		if home >= cur + mid:
    			cur = home # 다음 위치로 갱신
    			cnt += 1 # 공유기 1대 설치
    ```




### 함수 작성하기

- **로직이 함수를 건너뛰는 경우.**.. 가 크지 않게 하기

  - 함수 내부에서 다 처리되지 않고, 다른 함수로 로직들이 건너뛰어서 넘어가면, 사실 제대로 함수를 작성한 것이 아니다. 함수는 함수 그 자체만으로 역할을 다 할 수 있으면 좋다.

  - **예외처리를 많이 해두어야 하는 경우, flag로 함수 자체를 부분부분으로 분리하는 경우라면, 함수 자체를 분리하는 경우를 생각해보자.**

    - 예외처리가 아니라, 함수 2개로 예외 처리 경우, 예외 처리하지 않는 경우 이런식으로 나누라는 것이다.

    

- **규칙있게 겹치는 로직 -> 합치기!!!**

  - ```python
    # 규칙 있게 겹치는 로직
    elif flag == 1:
        check_and_rotate(cur+1,dir,1)
            
    elif flag == -1:
        check_and_rotate(cur-1,dir,-1)
        
    # 합친 로직
    check_and_rotate(cur+flag,dir,flag)
    ```



### 변하는 부분에 집중 & 코드 줄이기

- 시뮬레이션에서, 어떤 과정이 진행되면서 값이 변경되는 부분이 존재하기 마련이다. 값이 변경되는 부분이 문제가 원하는 부분인 경우가 많기 때문에, 그 부분을 잘 활용하자. 조금 추상적이지만, 이런 개념을 알고있으면 도움이 될 것 같아 적는다. 이런 상황을 조금 더 구체화 시키면 다음과 같다.

- 예를 들어, 20055_컨베이어벨트 문제에서 4번 과정이, 컨베이어 벨트 전체에서 내구도가 0인 갯수를 찾아 일정 갯수 이상이 되면 종료하는 부분을 말할 수 있다.

- ```python
  step = 1
  zd_cnt = 0 # 내구도가 0인 갯수
  while True:
      # 1. 벨트 회전
      # 내구도 유지, 내리는 위치라면 내리기
      tq.appendleft(tq.pop())
      rq.appendleft(rq.pop())
      if rq[n-1] == 1:
          rq[n-1] = 0
      
      # 2. 로봇 옮기기
      for idx in range(n-1,-1,-1):
          if rq[idx] == 1 and idx != n-1 and rq[idx+1] == 0 and tq[idx+1].d >= 1:
              # 1. 로봇 이동
              rq[idx] = 0
              rq[idx+1] = 1
              # 2. 내구도 감소
              tq[idx+1].d -= 1
              if tq[idx+1].d == 0:
                  zd_cnt += 1
              # 3. (옮긴 로봇이)내리는 위치인지 확인
              if idx+1 == n-1:
                  rq[idx+1] = 0
              
                  
      # 3. 내구도 체크 && 로봇 체크 후, 올리기
      if tq[0].d != 0 and rq[0] == 0:
          rq[0] = 1
          tq[0].d -= 1
          if tq[0].d == 0:
              zd_cnt += 1
              
      # 4. 내구도 0인 칸 개수 확인 후, 종료  
      if zd_cnt >= k:
          print(step)
          exit()
              
      step += 1
  ```

  

  1. 한번 어떤 과정을 할 때 마다, for문으로 전체 queue를 탐색해서 O(n)으로 (결국엔 n^2이 될거다. 반복문 안의 반복문이니까) 내구도 0인 개수를 찾는 방식이 있다. 아주 그냥 쌩 노다가인 것이다.
  2. 변하는 부분에 집중해서 생각해보자. 그러면, 내구도가 0인 것이 만들어지는 순간에만 체크하면 된다. 즉, 내구도가 줄어들 때에만, 그 칸의 내구도가 0이 되었나를 체크하고, count를 하나 늘려주면 된다. 위의 코드에서, #2, #3 마지막 부분에 존재한다. #4에서 전체 내구도 0인 갯수 체크한다.

  - 위와 같이, 전체 탐색이 아닌 변하는 부분에서만 개별 탐색을 통해서 시간복잡도를 줄일 수 있게 된다. (n -> 1로 줄임)

- 정리하면,

  1. **어떤 값이 변하는 부분에 집중하자.**
  2. **코드를 줄일 수 있다면, 줄이자(이 부분은 항상 명심하면 좋다. 반복문을 줄일 수 있으면 줄이고, 한두번만 사용되는 쓸데없는 변수는 줄이는 것이, 코드를 읽을 때 훨씬 편하다**.



### *인덱스 사용하기 - 리스트 탐색

- 리스트를 탐색할 때, 인덱스를 사용하는 경우가 있다.
- 인덱스로 탐색하다보니, 리스트의 범위를 넘어서 탐색해야 하는 경우가 생기는데, 얼핏 생각하면 try-catch로 에러를 처리해야하나..? 싶지만, 우리는 더 간단한 방법이 있다.
- **인덱스로 탐색하기 전에, 인덱스가 리스트의 길이를 안넘는지(해당 인덱스로 리스트를 탐색할 수 있는지) 체크하는 로직을 넣어주면 된다!! (if idx < len(list) )**

```python
# 1. 인덱스로 리스트 탐색하기
# 2. if-else 활용
# 3. continue 활용
# 4. 부등호 컨벤션
def can_go(line,slope):
    # 코딩컨벤션 : 등호 안붙이는 쪽으로, continue 사용 좋은 것인가
    i = 0
    while i < len(line)-1:
        # 내려가는지 확인하기
        if line[i] > line[i+1]:
            for a in range(1,l+1):
                # list 인덱싱 범위 넘어가는 것이면, 앞부분에 인덱스 조건 추가하면 된다
                if len(line)-1 < i+a or line[i] - line[i+a] != 1 or slope[i+a]:
                    return False
                
            slope[i+1:i+l+1] = [True]*l
            i += l
            continue # 이걸 지양할까 말까... return 느낌으로 좋은 것 같긴 한데
        
        i += 1
    
    return True
```



### if else문

- if를 사용하고, else는 지양하는 쪽으로 코딩을 하는 것이 좋다.
- 그렇게 하기 위해서는, **if (조건이 일치하지 않을 경우) : return** 을 활용해야한다.

```python
for a in range(1,l+1):
  	if len(line)-1 < i+a or line[i] - line[i+a] != 1 or slope[i+a]:
    		return False # 조건 불일치시, 로직 종료
		
    # 조건 1번 만족 시, 사용되는 코드부분
 
# 조건 전체 만족 시, 사용되는 코드부분
slope[i+1:i+l+1] = [True]*l

```



### continue문

- 함수에서, 로직을 끝내주는 return이 있다.
- **반복문에서, 로직을 끝내주는 것이 continue이다.**





### 부등호 사용하기

- 부등호는 웬만하면, '<' 를 사용('<='이 아니라)하는 쪽으로 코딩해보자



### 변수에서 현재, 다음 구분하기

```python
for y,x in coords:
	[m,s,d] = plain_f[y][x].popleft()

  ny = y # 원래 변수를 냅두고, 새로운 변수를 사용하는 것이 맞다
  nx = x
  for _ in range(s):
    ny = (ny + dy[d]) % n
    nx = (nx + dx[d]) % n
```



### 여러번 사용되는 계산식이면, 변수로 빼두고 사용하기

- 어떤 식이 여러번 사용된다는 뜻은, 결국 어떤 의미를 지닌 값이기 때문에, 알고리즘 로직에 있어서 여러번 사용되는 것이다.
- 의미있는 값은 변수로 빼두고 사용하는 것이, 로직을 읽을 때 편하다.

```python
'''
liquid[mid] + one 이라는 것이 여러번 사용된다.
여기서는 '두 용액의 합' 이라는 의미를 갖는데, 계속 사용됨에도 불구하고 항상 계산을 하고 있다.

계산은 한번만 하면 되니까, 변수로 따로 빼두고 사용하면 된다.
'''
while lo <= hi:
    mid = (lo+hi) // 2
    # ssum = liquid[mid] + one # 변수 하나 선언해서, 해당 변수로 사용하기

    if abs(ans) > abs(liquid[mid] + one): #1
        ans = liquid[mid] + one #2
        ans_liquid = [one,liquid[mid]]

    if liquid[mid] + one < 0: #3
        lo = mid + 1

    else:
        hi = mid - 1
```





### flag + while문 (+ 특정조건 체크)

- while문으로 계속 돌면서, 특정 상황이 계속 만족하는지 판단해야 하는 경우가 있다. 그래서 while문 안에 '특정 상황이 만족하는지 체크하는 로직'을 넣어두고, 그걸 만족하면 while문을 쭉 타고 만족하지 않으면 flag = Fail로 주고 break를 하는 분기코드를 자주 사용하게 된다.

```python
fail = False
while lo < hi:
    mid = (lo + hi) // 2

    #### 실패(flag = False & break)
    for i in range((hi - lo + 1) // 2):
        if paper[i] + paper[hi - i] != 1:
            fail = True
            break
    ###

    # 성공(while문 쭉 타기)
    hi = mid - 1


if fail:
    print("NO")
else:
    print("YES")
```

