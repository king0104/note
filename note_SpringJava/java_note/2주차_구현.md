## 2주차_구현

## 이론

- 상하좌우

  - 시뮬레이션 유형

  - 1. 이동하는 방향을 기록하는 배열 선언. dx,dy
  - 2. 이동하는 방향을 정의해두는 steps 변수 선언

- 시각
  - 완전탐색
    - for문 3개 이용해서 모든 경우의 수 다 탐색하는 것.



---



## 실전

- 왕실의 나이트

  - ```
    1. char to int
    2. 가능한 경로의 경우의 수를 배열에 저장하기!!! - 이게 진짜 중요!! 무조건 쓰인다.
    ```

  

- 게임 개발

  - **dx, dy라는 별도의 리스트**를 만들어 방향을 정해두는 것이 효과적이다. 그래야지 **반복문** 을 이용해서 모든 방향을 차례대로 확인할 수 있다.

    - ```java
      // 북, 동, 남, 서 방향 정의
      public static int dx[] = {-1,0,1,0};
      public static int dy[] = {0,1,0,-1};
  
    - 위의 리스트의 **인덱스**를 잘 설정해주면 반복문과 함께 사용할 수 있다.
  
      
  
  - 시뮬레이션 문제 : if,else if, 반복문 등 문제에서 제시한 알고리즘 방향을 **그대로** 따라가야한다!! 혼자 머릿속으로 고민하면서 자기가 알고리즘을 만들어내면 안된다!!
  
  
  
  - 2차원 배열 입력받기
  
    - ```java
      // 전체 맵 정보 입력받기
      for (int i = 0; i < n; i++) {
          StringTokenizer st3 = new StringTokenizer(br.readLine());
          for (int j = 0; j < m; j++) {
              arr[i][j] = Integer.parseInt(st3.nextToken());
          }
      }
      ```
    
    
    
  - 함수 사용 방법
  
    - ```java
      public static void turn_left(){
          dir -= 1;
          if (dir == -1)
              dir = 3;
      }
      ```
  
  - flag 변수 사용할 줄 알기. 모든 방향을 돌았는지 안돌았는지 검사하기 위해 int turn_time 사용
  - while(true){ break } 사용하는 반복문 익숙해지기



---

## 문제

1. 럭키 스트레이트
   - 붙어있는 문자열 하나를 받을 땐, stringtokenizer 필요없다
   - charAt으로 문자열의 원소 하나씩 끊어쓰기
   - char to int 는 아스키코드로 변환하기
   - 답지와 내가 다른 점 : 변수를 2개 설정해서 비교한 것이 아니라, 하나의 변수에 값을 쭉 한번 더하고, 한번 쭉 빼서 같은지 비교. **값을 비교할 때는 뺄셈으로 비교하는 방법**도 있다는 것을 알자.

2. 문자열 재정렬

   - 시행착오 1
     - 문자열 재정렬을 할 때 문자를 담아두는 배열을 선언하고 담아두었는데, 문제가 생겼다.
     - 전체 크기를 받을 수 있는 입력의 최대 크기로 선언하고 코드를 작성하니까 배열 특성상 입력받지 않은 부분의 공간이 그대로 남아 sort 시에 그 빈 공간도 같이 sort되어서 문제가 발생했다
     - 배열의 크기를 동적으로 정할 수 있는 **ArrayList**를 사용하였다!! 
   - 시행착오 2
     - str.charAt(i) - '0' 을 하면 숫자 그 자체가 되는데, 이 값을 아스키코드의 원래 값과 비교하려 했다. 당연히 결과가 나오지 않았고, print를 통해 디버깅을 해보니 숫자값과 비교해서 문자와 숫자를 나누어주어야 한다는 생각을 하였다.

   - 핵심 알고리즘

     - 주어진 입력을 문자와 숫자로 나누기

       - 문자와 숫자는 아스키코드로 연결되어 있으므로, 아스키코드 사용

     - 배열을 정렬하기

       - 가변적인 배열 선언 가능한 ArrayList 통해 정렬 시 딱 주어진 입력에 대해서만 정렬할 수 있도록 하기

       - ArrayList 사용

         - 객체.size()
         - 객체.get() 으로 각 원소 하나하나 뽑아서 써야한다.

         

     - 정렬한 배열 문자열로 만들기
       - stringbuilder 사용
       - sb.append() 로 각 원소 붙여주기
       - sb.ge
       - 이때, 객체.toString() 해주어야 문자열로 변환된다.



3. 문자열 재정렬
   - **순차적으로 접근하는 방법**을 항상 머릿속에 새겨야 한다!!! - 미친 그래서 구현에 있는거네;;; **완전탐색 유형**이잖아!!!!! 모든 경우의 수를 다 탐색해보는 것!!!!!!!!

4. 

5. 뱀

   - **방향 배열** 설정하기 : int dx[], dy[]
   - arr[x] [y] 라고 뒀으면
     1. 세로축이 x, 가로축이 y이다.
     2. 현재 방향을 방향 배열의 첫번째 원소로 두고, 돌아가면서 방향 지정하기

   - queue 라는 자료구조 이용

   - <**새로운 클래스** 제작>

     - 단순히 배열을 이용해서 값을 저장하는 것이 아니라,**새로운 클래스를 만들어서 여러 변수를 한번에 저장하고, 그 값들을 출력할 수 있는 메서드도 만들어두기**
     - 1. 클래스에 저장할 여러 **변수 선언** - **private** 으로 선언하기 - 해당 클래스 내에서만 사용
       2. 메서드 만들기
          1. **생성자 메서드** 만들기
          2. 해당 클래스에서 사용하는 **변수를 출력할 수 있는 기본적인 메서드 만들기** - ex) public int getX() 

     